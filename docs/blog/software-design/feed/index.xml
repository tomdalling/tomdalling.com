<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" version="2.0">
  <channel>
    <title>Tom Dalling</title>
    <link>https://www.tomdalling.com/?utm_source=rss&amp;utm_medium=rss</link>
    <atom:link href="https://www.tomdalling.com/blog/software-design/feed/" rel="self" type="application/rss+xml"/>
    <description>Web &amp; software developer</description>
    <language>en</language>
    <generator>Tom Dalling's fingertips</generator>
    <sy:updatePeriod>daily</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>FizzBuzz In Too Much Detail</title>
      <link>https://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>I know. FizzBuzz has been done to death. But I want to use it as a familiar
base upon which we can explore some of the common tradeoffs involved in writing
and maintaining software. In this article, I’ll show multiple implementations
of FizzBuzz, all designed to achieve different goals, and discuss the
implications of each.</p>
]]></description>
      <pubDate>Sun, 26 Apr 2015 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">com.tomdalling.blog.fizzbuzz</guid>
    </item>
    <item>
      <title>Why NSOrderedSet Doesn't Inherit From NSSet - A Real‑life Example of the Liskov Substitution Principle</title>
      <link>https://www.tomdalling.com/blog/software-design/why-nsorderedset-doesnt-inherit-from-nsset-a-real‑life-example-of-the-liskov-substitution-principle/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>There was an interesting question on StackOverflow this morning: <a href="http://stackoverflow.com/questions/11278995/why-doesnt-nsorderedset-inherit-from-nsset">Why doesn’t
NSOrderedSet inherit from NSSet?</a> It’s interesting because the reason is so
easy to miss. I thought it would make a good blog post because it turned out to
be a nice, real-life example of the <a href="http://tomdalling.com/blog/software-design/solid-class-design-the-liskov-substitution-principle">Liskov substitution principle</a> (herein
abbreviated to LSP).</p>
]]></description>
      <pubDate>Sun, 01 Jul 2012 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">627 http://tomdalling.com/blog/?p=627</guid>
    </item>
    <item>
      <title>Resource Acquisition is Initialisation (RAII) Explained</title>
      <link>https://www.tomdalling.com/blog/software-design/resource-acquisition-is-initialisation-raii-explained/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>In the competition to make the worst acronym, <a href="http://en.wikipedia.org/wiki/RAII">RAII</a> probably comes second
after <a href="http://en.wikipedia.org/wiki/HATEOAS">HATEOS</a>. Nevertheless, it is an important concept because it allows
you to write safer code in C++ — a harsh, unforgiving language that is
all too happy to help you shoot yourself in the foot.</p>

<p>This article will explain exception-safety and common pitfalls in C++. As we
work out how to avoid these problems, we will accidentally discover RAII. Then,
we will finish by defining exactly was RAII is, and where it is already being
used.</p>
]]></description>
      <pubDate>Thu, 17 May 2012 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">586 http://tomdalling.com/blog/?p=586</guid>
    </item>
    <item>
      <title>SOLID Class Design: The Interface Segregation Principle</title>
      <link>https://www.tomdalling.com/blog/software-design/solid-class-design-the-interface-segregation-principle/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>This is that last part of a five part series about <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" title="Principles of OOD">SOLID class design
principles</a> by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving
code that is maintainable, robust, and reusable. In this post, I will discuss
the Interface Segregation Principle.</p>

<blockquote>
  <p><strong>The Interface Segregation Principle (ISP)</strong>: <em>Clients should not be forced
to depend upon interfaces that they do not use</em>.</p>
</blockquote>
]]></description>
      <pubDate>Thu, 18 Feb 2010 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">352 http://tomdalling.com/?p=352</guid>
    </item>
    <item>
      <title>SOLID Class Design: The Dependency Inversion Principle</title>
      <link>https://www.tomdalling.com/blog/software-design/solid-class-design-the-dependency-inversion-principle/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>This is part four of a five part series about <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" title="Principles of OOD">SOLID class design principles</a>
by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving code that is
maintainable, robust, and reusable. In this post, I will discuss the Dependency
Inversion Principle.</p>

<blockquote>
  <p><strong>The Dependency Inversion Principle (DIP)</strong>: <em>High level modules should not
depend upon low level modules. Both should depend upon abstractions</em>.</p>
</blockquote>
]]></description>
      <pubDate>Sat, 19 Dec 2009 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">307 http://tomdalling.com/?p=307</guid>
    </item>
    <item>
      <title>SOLID Class Design: The Liskov Substitution Principle</title>
      <link>https://www.tomdalling.com/blog/software-design/solid-class-design-the-liskov-substitution-principle/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>This is part three of a five part series about <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" title="Principles of OOD">SOLID class design
principles</a> by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving
code that is maintainable, robust, and reusable. In this post, I will discuss
the Liskov Substitution Principle.</p>

<blockquote>
  <p><strong>The Liskov Substitution Principle (LSP)</strong>: <em>functions that use pointers to
base classes must be able to use objects of derived classes without knowing
it</em>.</p>
</blockquote>
]]></description>
      <pubDate>Sat, 21 Nov 2009 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">267 http://tomdalling.com/?p=267</guid>
    </item>
    <item>
      <title>SOLID Class Design: The Open Closed Principle</title>
      <link>https://www.tomdalling.com/blog/software-design/solid-class-design-the-open-closed-principle/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>This is part two of a five part series about <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" title="Principles of OOD">SOLID class design principles</a>
by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving code that is
maintainable, robust, and reusable. In this post, I will discuss the Open
Closed Principle.</p>

<blockquote>
  <p><strong>The Open Closed Principle (OCP)</strong>: <em>You should be able to extend a classes behavior, without modifying it</em>.</p>
</blockquote>
]]></description>
      <pubDate>Sat, 14 Nov 2009 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">245 http://tomdalling.com/?p=245</guid>
    </item>
    <item>
      <title>SOLID Class Design: The Single Responsibility Principle</title>
      <link>https://www.tomdalling.com/blog/software-design/solid-class-design-the-single-responsibility-principle/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>This is part one of a five part series about <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" title="The Principles of OOD">SOLID class design principles</a>
by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving code that is
maintainable, robust, and reusable. In this post, I will discuss the Single
Responsibility Principle.</p>

<blockquote>
  <p><strong>The Single Responsibility Principle (SRP)</strong>: <em>A class should have one, and only one, reason to change</em>.</p>
</blockquote>
]]></description>
      <pubDate>Thu, 12 Nov 2009 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">232 http://tomdalling.com/?p=232</guid>
    </item>
    <item>
      <title>Model View Controller Explained</title>
      <link>https://www.tomdalling.com/blog/software-design/model-view-controller-explained/?utm_source=rss&amp;utm_medium=rss</link>
      <description><![CDATA[<p>Model view controller (MVC) is a very useful and popular design pattern. If
you’re writing software, you should know it. Unfortunately it’s also one of the
hardest to truly understand. In this article I will provide what I think is the
simplest explanation of MVC, and why you should use it.</p>
]]></description>
      <pubDate>Sun, 31 May 2009 00:00:00 -0000</pubDate>
      <category><![CDATA[Software Design]]></category>
      <guid isPermaLink="false">3 http://tomdalling.com/?p=3</guid>
    </item>
  </channel>
</rss>
