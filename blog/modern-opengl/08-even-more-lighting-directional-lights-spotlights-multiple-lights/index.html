<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Modern OpenGL 08 – Even More Lighting: Directional Lights, Spotlights, &amp; Multiple Lights — Tom Dalling</title>
    <link rel="stylesheet" href="/style.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather+Sans:wght@700&amp;family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&amp;family=Montserrat:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

    <meta name="twitter:site" content="@tom_dalling">
    <meta name="twitter:creator" content="@tom_dalling">
    <link rel="alternate" type="application/rss+xml" title="Tom Dalling" href="https://www.tomdalling.com/blog/feed/">
  <link rel="canonical" href="https://www.tomdalling.com/blog/modern-opengl/08-even-more-lighting-directional-lights-spotlights-multiple-lights/">
<meta property="og:title" content="Modern OpenGL 08 – Even More Lighting: Directional Lights, Spotlights, &amp; Multiple Lights">
<meta property="og:url" content="https://www.tomdalling.com/blog/modern-opengl/08-even-more-lighting-directional-lights-spotlights-multiple-lights/">
<meta property="og:image" content="https://www.tomdalling.com/images/posts/modern-opengl-08/main-image.png">
<meta name="twitter:card" content="summary_large_image">
</head>

  <body>

    <header class="tw-mb-6 tw-py-2 tw-bg-gray-100 tw-border-b tw-border-gray-200 tw-font-title">
      <nav class="tw-container tw-mx-auto max-w-screen-xl tw-space-x-8 tw-px-4">
        <a href="/" class="tw-text-xl tw-text-black">Tom Dalling</a>
        <a href="/blog/" class="tw-text-black">Blog</a>
      </nav>
    </header>

    <div class="tw-container tw-mx-auto tw-flex tw-flex-col lg:tw-flex-row">

      <main class="tw-flex-1 tw-min-w-0 tw-px-4"><article class="post post-single">

  <header>
    <h1><a href="/blog/modern-opengl/08-even-more-lighting-directional-lights-spotlights-multiple-lights/">Modern OpenGL 08 – Even More Lighting: Directional Lights, Spotlights, &amp; Multiple Lights</a></h1>
    <small class="meta">
      <span class="post-date">01 Nov, 2014</span>
      
      —
      Category: <a class="category" href="/blog/category/modern-opengl/">Modern OpenGL Series</a>
      —
      Suggest changes <a class="post-github" href="https://github.com/tomdalling/tomdalling.com/tree/main/input/posts/2014-11-01_08-even-more-lighting-directional-lights-spotlights-multiple-lights.markdown">on GitHub</a>
    </small>
    <div class="main-image">
      <img src="/images/posts/modern-opengl-08/main-image.png" class="img-responsive">
      
    </div>
  </header>

  <div class="post-content body-text">
<p>In this article, we will be adding directional lights, spotlights, and allowing
for multiple lights instead of just one. This is the final article on lighting
– at least for a while.</p>

<!--more-->
<p></p>
<div class="modern-opengl-preamble">
  <h2>Accessing The Code</h2>

  <p>
    Download all the code as a zip from here:
    <a href="https://github.com/tomdalling/opengl-series/archive/master.zip">
      https://github.com/tomdalling/opengl-series/archive/master.zip
    </a>
  </p>

  <p>
    All the code in this series of articles is available from github:
    <a href="https://github.com/tomdalling/opengl-series">https://github.com/tomdalling/opengl-series</a>.
    You can download a zip of all the files from that page, or you can clone the
    repository if you are familiar with git.
  </p>

  <p class="builds-on-previous">
    This article builds on the code from the previous article.
  </p>

  <p>
    The code for this article can be found in the
    <a class="source_folder" href="https://github.com/tomdalling/opengl-series/tree/master/source/08_even_more_lighting">
      <code>source/08_even_more_lighting</code>
    </a>
    folder. On OS X, open the <code>opengl-series.xcodeproj</code> file in the
    root folder, and select the target that corresponds with this article. On
    Windows, open the <code>opengl-series.sln</code> file in Visual Studio 2013,
    and open the project that corresponds with this article.
  </p>

  <p>
    The project includes all of its dependencies, so you shouldn't have to
    install or configure anything extra. Please let me know if you have
    any issues compiling and running the code.
  </p>
</div>


<h2>Directional Lights</h2>

<figure class="nopadding">
  <img src="/images/posts/modern-opengl-08/directional-light.jpg">
</figure>

<p>Directional lights are lights that shine in a single, uniform direction. That
is, all rays of light are parallel to each other. Pure directional lights do
not exist (except maybe lasers?) but they are often used in computer graphics
to imitate strong light sources that are very far away, such as the Sun. The
Sun radiates light in all directions, like a point light. Over an enormous
distance, however, the tiny fraction of light rays that make it to earth appear
to be almost parallel.</p>

<blockquote class="pull-right">
  Directional lights are implemented such that they ignore attenuation.
</blockquote>

<p>As we saw in the <a href="/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/">previous article on homogeneous
coordinates</a>, directional lights can be thought of as
point lights that are infinitely far away. This causes an unfortunate
interaction with attenuation. Attenuation is the reduction of light intensity
over distance – the greater the distance, the dimmer the light is. If there is
even the tiniest amount of attenuation, over an infinite distance the light
becomes infinitely dim (i.e. invisible). For this reason, directional lights
are implemented such that they ignore attenuation. This kind-of makes sense if
we’re using directional lights to represent the Sun, because the sunlight we
see here on Earth doesn’t appear to be attenuated. That is, sunlight doesn’t
appear to get dimmer as it gets closer to the ground.</p>

<blockquote class="pull-right">
  We can represent the direction of a directional light with a homogeneous
  coordinate by setting $$W = 0$$.
</blockquote>

<p>Unlike point lights, directional lights do not need a position coordinate. A
directional light only needs a single 3D vector that represents the direction
of all the rays of light.  However, the GLSL lighting code in our shader
expects every light to have a position. Luckily, we can represent the direction
of a directional light with a homogeneous coordinate by setting $$W = 0$$.  As
explained in the <a href="/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/">previous article on homogeneous
coordinates</a>, when $$W = 0$$ in a 4D coordinate, it
represents the direction towards a point that is infinitely far away.  So if the
coordinate represents the direction <em>towards</em> the Sun, we can just negate it to
produce the direction <em>away</em> from the Sun, which is the direction of the light
rays. Using this method of representing directional lights inside the position
vector, we could have code that looks like this:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">uniform</span> <span class="kt">vec4</span> <span class="n">lightPosition</span><span class="p">;</span>

<span class="c1">// check if this is a directional light</span>
<span class="k">if</span><span class="p">(</span><span class="n">lightPosition</span><span class="p">.</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// it is a directional light.</span>
  <span class="c1">// get the direction by converting to vec3 (ignore W) and negate it</span>
  <span class="kt">vec3</span> <span class="n">lightDirection</span> <span class="o">=</span> <span class="o">-</span><span class="n">lightPosition</span><span class="p">.</span><span class="n">xyz</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// NOT a directional light</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As an example, let’s say that <code>lightPosition</code> coordinate is $$(1, 0, 0, 0)$$,
which represents a point infinitely far away down the <em>positive</em> X axis.  If we
take the $$X$$, $$Y$$, and $$Z$$ values then negate them, we get $$(-1, 0,
0)$$, which indicates that the light is shining down the <em>negative</em> X axis.</p>

<p>The GLSL lighting code we implemented in the previous article uses the
direction from the surface to the light (in a variable named <code>surfaceToLight</code>),
so we don’t actually need to negate anything. The GLSL for directional lights
in this article looks like this:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec3</span> <span class="nf">ApplyLight</span><span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">vec3</span> <span class="n">surfaceColor</span><span class="p">,</span> <span class="kt">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="kt">vec3</span> <span class="n">surfacePos</span><span class="p">,</span> <span class="kt">vec3</span> <span class="n">surfaceToCamera</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">vec3</span> <span class="n">surfaceToLight</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//directional light</span>
        <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//no attenuation for directional lights</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// NOT directional light</span>
        <span class="c1">//... (code ommited)</span>
    <span class="p">}</span>

    <span class="c1">// the rest of the lighting calculation</span>
    <span class="c1">//... (code ommited)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2>Spotlights</h2>

<figure class="nopadding">
  <img src="/images/posts/modern-opengl-08/spotlight.jpg">
</figure>

<p>The final type of light we will be implementing is spotlights. Spotlights are
very similar to point lights, except that instead of radiating light out in all
directions, the light rays are restricted to a cone shape. The light rays are
<em>not</em> parallel like directional lights, but they do shine out in a general
direction. Think of a flashlight. There is a light bulb in there that acts like
a point light, but there is also a reflective curved surface that restricts
where the light can shine.</p>

<blockquote class="pull-right">
  We will model spotlights as point lights with a cone restriction.
</blockquote>

<p>We will model spotlights as point lights with a cone restriction. Everything
that applies to point lights also applies to spotlights, except for two
extra variables: the direction of the cone, and the angle of the cone. Here
is the definition of the <code>Light</code> struct for this article:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">uniform</span> <span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
   <span class="kt">vec4</span> <span class="n">position</span><span class="p">;</span>
   <span class="kt">vec3</span> <span class="n">intensities</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">attenuation</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">ambientCoefficient</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">coneAngle</span><span class="p">;</span>    <span class="c1">// new</span>
   <span class="kt">vec3</span> <span class="n">coneDirection</span><span class="p">;</span> <span class="c1">// new</span>
<span class="p">};</span>
</code></pre></div></div>

<p>There are two new variables that were added in order to implement spotlights:
<code>coneAngle</code> and <code>coneDirection</code>. The <code>coneDirection</code> variable is the direction
from the point of the cone, through the center of the cone. The <code>coneAngle</code>
variable is the angle between the center and the side of the cone, in degrees.</p>

<figure class="black nopadding">
  <img src="/images/posts/modern-opengl-08/cone-direction-angle.jpg">
</figure>

<blockquote class="pull-right">
  If the pixel is outside of the cone, then we set the attenuation
  factor to zero.
</blockquote>

<p>The implementation is fairly simple. For every pixel, we check whether it is
inside or outside of the light cone. If it’s inside, we continue with the
lighting calculations as we normally would. If the pixel is <em>outside</em> of the
cone, then we set the attenuation factor to zero, which will make the light ray
invisible. Here is the GLSL that implements the cone restriction:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">lightToSurfaceAngle</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceToLight</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">coneDirection</span><span class="p">))));</span>
<span class="k">if</span><span class="p">(</span><span class="n">lightToSurfaceAngle</span> <span class="o">&gt;</span> <span class="n">light</span><span class="p">.</span><span class="n">coneAngle</span><span class="p">){</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The first line is pretty dense, so let me explain it by break it down into
smaller steps:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. Get the direction for the center of the cone. The `normalize`</span>
<span class="c1">//    function is called just in case `light.coneDirection` isn't</span>
<span class="c1">//    already a unit vector.</span>
<span class="kt">vec3</span> <span class="n">coneDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">coneDirection</span><span class="p">);</span>

<span class="c1">// 2. Get the direction of the ray of light. This is the opposite</span>
<span class="c1">//    of the direction from the surface to the light.</span>
<span class="kt">vec3</span> <span class="n">rayDirection</span> <span class="o">=</span> <span class="o">-</span><span class="n">surfaceToLight</span><span class="p">;</span>

<span class="c1">// 3. Get the angle between the center of the cone and the ray of light.</span>
<span class="c1">//    The combination of `acos` and `dot` return the angle in radians, then</span>
<span class="c1">//    we convert it to degrees.</span>
<span class="kt">float</span> <span class="n">lightToSurfaceAngle</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">rayDirection</span><span class="p">,</span> <span class="n">coneDirection</span><span class="p">)))</span>

<span class="c1">// 4. Check if the angle is outside of the cone. If so, set the attenuation</span>
<span class="c1">//    factor to zero, to make the light ray invisible.</span>
<span class="k">if</span><span class="p">(</span><span class="n">lightToSurfaceAngle</span> <span class="o">&gt;</span> <span class="n">light</span><span class="p">.</span><span class="n">coneAngle</span><span class="p">){</span>
  <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>These cone restrictions are going to be applied to all non-directional lights, which
includes point lights. To stop the restrictions from applying to a point light,
all we have to do is set <code>coneAngle</code> to <code>180.0</code>, which means that light can
shine in all directions.</p>

<h2>Multiple Lights</h2>

<blockquote class="pull-right">
  We are just refactoring the existing fragment shader code and adding a loop.
</blockquote>

<p>The fragment shader for the previous article only implemented a single light so
let’s replace the single light with an array of lights. Then we can loop over
them in the fragment shader, and apply them all to the scene. We aren’t really
implementing anything new here. We are just refactoring the existing fragment
shader code and adding a loop.</p>

<p>The first step is to remove the single light uniform from the fragment shader,
and replace it with an array. This is the old GLSL from the previous article:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// code from previous article (a single light)</span>
<span class="k">uniform</span> <span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
   <span class="kt">vec3</span> <span class="n">position</span><span class="p">;</span>
   <span class="kt">vec3</span> <span class="n">intensities</span><span class="p">;</span> <span class="c1">//a.k.a the color of the light</span>
   <span class="kt">float</span> <span class="n">attenuation</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">ambientCoefficient</span><span class="p">;</span>
<span class="p">}</span> <span class="n">light</span><span class="p">;</span>
</code></pre></div></div>

<p>And this is the new code, with an array of lights:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// array of lights</span>
<span class="cp">#define MAX_LIGHTS 10
</span><span class="k">uniform</span> <span class="kt">int</span> <span class="n">numLights</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
   <span class="kt">vec4</span> <span class="n">position</span><span class="p">;</span>
   <span class="kt">vec3</span> <span class="n">intensities</span><span class="p">;</span> <span class="c1">//a.k.a the color of the light</span>
   <span class="kt">float</span> <span class="n">attenuation</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">ambientCoefficient</span><span class="p">;</span>
   <span class="kt">float</span> <span class="n">coneAngle</span><span class="p">;</span>
   <span class="kt">vec3</span> <span class="n">coneDirection</span><span class="p">;</span>
<span class="p">}</span> <span class="n">allLights</span><span class="p">[</span><span class="n">MAX_LIGHTS</span><span class="p">];</span>
</code></pre></div></div>

<p>This implementation is very similar to the lighting implementation in the old
fixed-function pipeline of OpenGL. There is a maximum number of lights, set
in the <code>MAX_LIGHTS</code> constant. Then there is an uniform variable that
hold the array of lights, called <code>allLights</code>. Lastly, there is a uniform
variable that holds the number of lights we are actually using, called
<code>numLights</code>.</p>

<p>The next step is to refactor the GLSL code so that it loops over the array.
We extract all the lighting code into a function called <code>ApplyLight</code>, which
does the entire lighting calculation for a single light. Here is the
GLSL for the <code>ApplyLight</code> function:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec3</span> <span class="nf">ApplyLight</span><span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="kt">vec3</span> <span class="n">surfaceColor</span><span class="p">,</span> <span class="kt">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="kt">vec3</span> <span class="n">surfacePos</span><span class="p">,</span> <span class="kt">vec3</span> <span class="n">surfaceToCamera</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">vec3</span> <span class="n">surfaceToLight</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//directional light</span>
        <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//no attenuation for directional lights</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//point light</span>
        <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">surfacePos</span><span class="p">);</span>
        <span class="kt">float</span> <span class="n">distanceToLight</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">surfacePos</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">attenuation</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">distanceToLight</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

        <span class="c1">//cone restrictions (affects attenuation)</span>
        <span class="kt">float</span> <span class="n">lightToSurfaceAngle</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceToLight</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">coneDirection</span><span class="p">))));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">lightToSurfaceAngle</span> <span class="o">&gt;</span> <span class="n">light</span><span class="p">.</span><span class="n">coneAngle</span><span class="p">){</span>
            <span class="n">attenuation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//ambient</span>
    <span class="kt">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambientCoefficient</span> <span class="o">*</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensities</span><span class="p">;</span>

    <span class="c1">//diffuse</span>
    <span class="kt">float</span> <span class="n">diffuseCoefficient</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">surfaceToLight</span><span class="p">));</span>
    <span class="kt">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">diffuseCoefficient</span> <span class="o">*</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensities</span><span class="p">;</span>
    
    <span class="c1">//specular</span>
    <span class="kt">float</span> <span class="n">specularCoefficient</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">diffuseCoefficient</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">specularCoefficient</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">surfaceToCamera</span><span class="p">,</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceToLight</span><span class="p">,</span> <span class="n">normal</span><span class="p">))),</span> <span class="n">materialShininess</span><span class="p">);</span>
    <span class="kt">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">specularCoefficient</span> <span class="o">*</span> <span class="n">materialSpecularColor</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensities</span><span class="p">;</span>

    <span class="c1">//linear color (color before gamma correction)</span>
    <span class="k">return</span> <span class="n">ambient</span> <span class="o">+</span> <span class="n">attenuation</span><span class="o">*</span><span class="p">(</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code>ApplyLight</code> function takes a single light as an argument, but it also
takes some arguments that describe the surface that is being lit:
<code>surfaceColor</code>, <code>normal</code>, <code>surfacePos</code>, and <code>surfaceToCamera</code>. Because all the
lights are acting upon the same surface, we calculate these surface-related
variables once, and pass them in as arguments for every light.</p>

<p>With all the lighting code extracted into a function, we can loop through
all the lights. For each light, we call <code>ApplyLight</code> and add all the
results together to get the color for the surface:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec3</span> <span class="n">linearColor</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numLights</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">linearColor</span> <span class="o">+=</span> <span class="n">ApplyLight</span><span class="p">(</span><span class="n">allLights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">surfacePos</span><span class="p">,</span> <span class="n">surfaceToCamera</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2>C++ Code Changes</h2>

<p>The changes to the C++ code are mainly just mirrors of the GLSL changes.</p>

<p>The <code>Light</code> struct changes slightly, to accommodate directional lights and
spotlights. The <code>position</code> element changes from a <code>glm::vec3</code> to a
<code>glm::vec4</code>, and we add the two spotlight cone variables <code>coneDirection</code>
and <code>coneAngle</code>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">intensities</span><span class="p">;</span> <span class="c1">//a.k.a. the color of the light</span>
    <span class="kt">float</span> <span class="n">attenuation</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ambientCoefficient</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">coneAngle</span><span class="p">;</span> <span class="c1">// new</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">coneDirection</span><span class="p">;</span> <span class="c1">// new</span>
<span class="p">};</span>
</code></pre></div></div>

<p>In the globals, we change the single light to a <code>std::vector</code> of lights:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Light gLight; // used to be this in previous article</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Light</span><span class="o">&gt;</span> <span class="n">gLights</span><span class="p">;</span>
</code></pre></div></div>

<p>In the <code>RenderInstance</code> function, we now have to loop through all the
lights when we set the uniforms:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">setUniform</span><span class="p">(</span><span class="s">"numLights"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">gLights</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gLights</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"position"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"intensities"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">intensities</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"attenuation"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">attenuation</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"ambientCoefficient"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ambientCoefficient</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"coneAngle"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">coneAngle</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"coneDirection"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">coneDirection</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This uses a function called <code>SetLightUniform</code>, which constructs the uniform names
based on the struct element and the index (e.g. <code>"allLights[2].coneAngle"</code>).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">SetLightUniform</span><span class="p">(</span><span class="n">tdogl</span><span class="o">::</span><span class="n">Program</span><span class="o">*</span> <span class="n">shaders</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">propertyName</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">lightIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">ss</span><span class="p">;</span>
    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">"allLights["</span> <span class="o">&lt;&lt;</span> <span class="n">lightIndex</span> <span class="o">&lt;&lt;</span> <span class="s">"]."</span> <span class="o">&lt;&lt;</span> <span class="n">propertyName</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uniformName</span> <span class="o">=</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>

    <span class="n">shaders</span><span class="o">-&gt;</span><span class="n">setUniform</span><span class="p">(</span><span class="n">uniformName</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code>AppMain</code>, we create a spotlight and a directional light:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// setup lights</span>
<span class="n">Light</span> <span class="n">spotlight</span><span class="p">;</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//strong white light</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">attenuation</span> <span class="o">=</span> <span class="mf">0.1</span><span class="n">f</span><span class="p">;</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">ambientCoefficient</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span> <span class="c1">//no ambient light</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">coneAngle</span> <span class="o">=</span> <span class="mf">15.0</span><span class="n">f</span><span class="p">;</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">coneDirection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="n">Light</span> <span class="n">directionalLight</span><span class="p">;</span>
<span class="n">directionalLight</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//w == 0 indications a directional light</span>
<span class="n">directionalLight</span><span class="p">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.1</span><span class="p">);</span> <span class="c1">//weak yellowish light</span>
<span class="n">directionalLight</span><span class="p">.</span><span class="n">ambientCoefficient</span> <span class="o">=</span> <span class="mf">0.06</span><span class="p">;</span>

<span class="n">gLights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spotlight</span><span class="p">);</span>
<span class="n">gLights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">directionalLight</span><span class="p">);</span>
</code></pre></div></div>

<p>And in the <code>Update</code> function, we make the key <kbd>1</kbd> change the position and
direction of the spotlight:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//move light</span>
<span class="k">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="sc">'1'</span><span class="p">)){</span>
    <span class="n">gLights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">position</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">gCamera</span><span class="p">.</span><span class="n">position</span><span class="p">(),</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="n">gLights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">coneDirection</span> <span class="o">=</span> <span class="n">gCamera</span><span class="p">.</span><span class="n">forward</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h2>Further Lighting</h2>

<p>At this point, we have basically implemented all the lighting options that were
available in the old fixed-function API of OpenGL. We went a step further by
implementing per-fragment lighting instead of per-vertex lighting, but there
are many more improvements that we haven’t covered.  Lighting is a huge subject,
so for now I’m just going to give a brief overview of a few advanced lighting
topics.</p>

<h3>Blinn-Phong</h3>

<p>Our lighting in this series is an implemention of the Phong reflection model.
There is a slightly better version of this algorithm, called the <a href="http://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model">Blinn-Phong</a>
reflection model. Blinn-Phong is a bit more accurate, and has slightly
better performance too.</p>

<h3>Fancier Spotlights</h3>

<p>The spotlight implementation in this article is very basic. It could be improved by
softening the hard edges in GLSL using the <a href="https://www.opengl.org/sdk/docs/man/html/mix.xhtml">mix function</a>. You could also
sample a flashlight texture to stop the light from looking so circular and flat.</p>

<h3>Deferred Rendering</h3>

<figure class="youtube">
  <iframe src="https://www.youtube.com/embed/vooznqE-XMM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</figure>


<p>The way we have implemented lighting is known as <em>forward rendering</em>,
and there are a couple of annoying issues associated with it. Firstly, there
is a limit to the number of lights we can have. Secondly, every pixel that gets
drawn requires calculations for every light – even if there are lights
that do not affect the pixel – which can be a performance issue. Ideally,
we want to be able to have thousands of lights with decent performance. To
address these issues, we could use <a href="http://gamedev.stackexchange.com/questions/74/what-is-deferred-rendering">deferred rendering</a>.</p>

<p>Deferred rendering is a technique where you split rendering up into multiple
passes. The first pass renders geometry without any lights. In subsequent
passes, the lights are rendered one at a time. Lighting happens to every
<em>pixel</em>, instead of every <em>fragment</em>, which improves performance. You are
also able to restrict which pixels each light affects to further improve
performance.</p>

<p>In summary, deferred rendering allows lots of lights with decent performance,
but it is more complicated than forward rendering.</p>

<h3>Shadows</h3>

<figure class="youtube">
  <iframe src="https://www.youtube.com/embed/0EjvtQdTHB0" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</figure>


<p>Despite that fact that everyone loves the look of them, nice shadows are a huge
can of worms, and can be extremely complicated. All the following techniques
are way more complicated than what this series of articles has covered so far.</p>

<p><a href="http://codeflow.org/entries/2013/feb/15/soft-shadow-mapping/">Shadow maps</a> are probably the simplest technique, but the resulting shadows
can be weird and pixelated.</p>

<p><a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch11.html">Shadow volumes</a> give pixel-perfect results, but they require complicated
processing on your geometry, which is slow.</p>

<p>When the light and the geometry are both static, then <a href="http://en.wikipedia.org/wiki/Lightmap">lightmaps</a> are accurate
and have good performance.</p>

<p>Don’t even get me started on <a href="http://gamedev.stackexchange.com/questions/23/what-is-ambient-occlusion">ambient occlusion</a>.</p>

<h3>High-dynamic-range (HDR)</h3>

<figure class="nopadding">
  <img class="captioned" src="/images/posts/modern-opengl-08/hdr.jpg">
  <figcaption>
    Image courtesy of 
    <a href="http://commons.wikimedia.org/wiki/File:Slowenien,_Portorose_(HDR-Aufnahme_vs_Normalbelichtung).jpg">
      Richard Huber
    </a>
  </figcaption>
</figure>

<p>Notice how the colors from all the lights are added together in our fragment
shader. The RGBA values are supposed to be within the 0.0 to 1.0 range, so what
happens if there are lots of lights, and the sum ends up being greater than
1.0? The colors would get clamped, and look weird. Also, if the lights
are too dim, the whole scene could look basically black, with no detail.
High-dynamic-range (HDR) rendering can help to fix these problems.</p>

<p>The human eye adjusts depending on the brightness of what it’s looking at. If
you are in a dark room for long enough, your pupils dilate to allow more light
to reach your retina, which makes the room seem brighter. If you walk outside
into bright sunlight, the opposite happens, so that you don’t go blind from the
intense light. HDR rendering sort of imitates how your eye works, in order to
keep the details visible in very dark and very bright scenes. RGB values are
allowed to go above 1.0 during lighting calculations, then the values are later
rescaled so that they fit nicely within the 0.0–1.0 range.</p>

<h3>Subsurface Scattering</h3>

<figure class="black">
  <img src="/images/posts/modern-opengl-08/sss.png">
  <figcaption>
    Image courtesy of 
    <a href="http://commons.wikimedia.org/wiki/File:Subsurface_scattering.png">
      Piotrek Chwała
    </a>
  </figcaption>
</figure>

<p>Light doesn’t just reflect <em>off</em> of surfaces, it can travel <em>through</em> them too.
When light penetrates a surface, it changes the color of that surface. Rendering
this color change is called <a href="http://www.iryoku.com/screen-space-subsurface-scattering">subsurface scattering</a>.</p>

<p>Even though skin looks fairly opaque, subsurface scattering is generally used for
realistic rendering of human skin. Without it, skin tends to look like painted
plastic.</p>

<h3>Emissive Surfaces</h3>

<figure class="nopadding">
  <img class="captioned" src="/images/posts/modern-opengl-08/emissive.png">
  <figcaption>Emissive surfaces from the game Borderlands</figcaption>
</figure>

<p>In our implementation, only lights can illuminate a surface. Some surfaces, however,
provide their own illumination, which makes it look like they are glowing. Think of
a firefly, glow-in-the-dark stickers, or <a href="http://en.wikipedia.org/wiki/List_of_bioluminescent_fungi">those weird glowing mushrooms</a>.</p>

<p>Emissive lights are pretty easy to implement in OpenGL. Send an extra color uniform
to the shaders, along with the materials texture and shininess, and add that color
to the final color. Alternatively, you can send an extra texture instead of a
single color.</p>

<h3>Normal Mapping</h3>

<figure>
  <img src="/images/posts/modern-opengl-08/normal-map.png">
  <figcaption>
    Image courtesy of 
    <a href="http://commons.wikimedia.org/wiki/File:Normal_map_example.png">
      Paolo Cignoni
    </a>
  </figcaption>
</figure>

<p>3D meshes have limits to the number of vertices they can contain, due to performance.
Making a surface rough or bumpy with geometry can take a lot of vertices, so
<a href="http://en.wikipedia.org/wiki/Normal_mapping">normal maps</a> are often used instead. Normal maps can be used to make an angular-looking
3D model look less angular, and more realistic.</p>

<p>A normal map is a texture that affects the surface normal. It is like the
surface texture that we have implemented, except it contains XYZ vectors
instead of RGB colors. The surface normal is an important part of the lighting
calculations, and it affects the brightness of each pixel.</p>

<h2>Conclusion</h2>

<p>That wraps up our lighting implementation for now. After adding directional
lights and spotlights, we have recreated the functionality that was available
in the old fixed-function OpenGL API.</p>

</div>

  <footer>
    <div class="tw-rounded-3xl tw-bg-pink-100 tw-p-8 tw-my-16 tw-text-center tw-bg-opacity-50">
      <p class="tw-text-2xl tw-uppercase tw-text-pink-900 tw-font-black tw-mb-4">Enjoy this?</p>

      <p class="tw-flex tw-flex-col sm:tw-flex-row tw-justify-center tw-item-center sm:tw-items-baseline">
        <a href="/feed/" class="tw-flex-1 tw-bg-pink-500 tw-py-3 tw-px-4 tw-rounded-lg tw-text-pink-100 tw-ring-2 tw-ring-pink-300 hover:tw-text-white">Subscribe via RSS</a>
        <span class="tw-flex-none tw-px-8 tw-py-4 tw-text-pink-800">or</span>
        <a href="https://twitter.com/tom_dalling" class="tw-flex-1 tw-bg-pink-500 tw-py-3 tw-px-4 tw-rounded-lg tw-text-pink-100 tw-ring-2 tw-ring-pink-300 hover:tw-text-white">Follow on Twitter</a>
      </p>

      <p class="tw-text-center tw-mt-4 tw-mb-0 tw-text-pink-900">
        <em>Found a mistake?</em> Pull requests are welcome on
        <a href="https://github.com/tomdalling/tomdalling.com/whatever">GitHub</a>.
      </p>
</div>

    


    
      <h2>Comments</h2>
      <div id="disqus_thread"></div>
      <script type="text/javascript" id="disqus_script">
        var disqus_shortname = "tomdalling";
        var disqus_identifier = "com.tomdalling.modern-opengl-series.08";
        var disqus_title = "Modern OpenGL 08 – Even More Lighting: Directional Lights, Spotlights, & Multiple Lights";
        var disqus_url = "https://www.tomdalling.com/blog/modern-opengl/08-even-more-lighting-directional-lights-spotlights-multiple-lights/";

        (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments.</a>
</noscript>
    

  </footer>
</article>
</main>

      <aside class="tw-px-4 tw-text-center lg:tw-text-left lg:tw-w-1/3 tw-flex-none">

        <div class="tw-text-lg tw-font-title tw-mb-1">Subscribe</div>
        <ul class="tw-space-y-2">
          <li>
            <a href="/blog/feed/">
              <i class="fa fa-rss"></i> RSS
            </a>
          </li>
          <li>
            <a href="https://twitter.com/tom_dalling">
              <i class="fa fa-twitter"></i> Twitter
            </a>
          </li>
        </ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Recent Posts</div>
        <ul class="recent-posts tw-space-y-2">
          
        <li><a href="/blog/mentoring/marketing-yourself-as-a-junior-engineer/">Marketing Yourself As A Junior Engineer</a></li>
<li><a href="/blog/random-stuff/context-costs-and-benefits/">Context, Costs, and Benefits</a></li>
<li><a href="/blog/software-design/thoughts-on-schema-library-design/">Thoughts On Schema Library Design</a></li>
<li><a href="/blog/software-processes/github-workflow-for-automated-gem-releases/">GitHub Workflow For Automated Gem Releases</a></li>
<li><a href="/blog/testing/monologue-on-end-to-end-testing/">Monologue On End-To-End Testing</a></li>
</ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Categories</div>
        <ul class="categories tw-space-y-2">
          
        <li>
            <a href="/blog/cocoa/" class="category">Cocoa</a>
            (<span class="post-count">5</span>
            <a class="feed" href="/blog/cocoa/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/coding-styleconventions/" class="category">Coding Style/Conventions</a>
            (<span class="post-count">3</span>
            <a class="feed" href="/blog/coding-styleconventions/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/coding-tips/" class="category">Coding Tips</a>
            (<span class="post-count">4</span>
            <a class="feed" href="/blog/coding-tips/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/mentoring/" class="category">Mentoring Notes</a>
            (<span class="post-count">3</span>
            <a class="feed" href="/blog/mentoring/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/random-stuff/" class="category">Miscellaneous</a>
            (<span class="post-count">4</span>
            <a class="feed" href="/blog/random-stuff/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/modern-opengl/" class="category">Modern OpenGL Series</a>
            (<span class="post-count">10</span>
            <a class="feed" href="/blog/modern-opengl/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/ruby/" class="category">Ruby</a>
            (<span class="post-count">2</span>
            <a class="feed" href="/blog/ruby/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/software-design/" class="category">Software Design</a>
            (<span class="post-count">12</span>
            <a class="feed" href="/blog/software-design/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/software-processes/" class="category">Software Processes</a>
            (<span class="post-count">3</span>
            <a class="feed" href="/blog/software-processes/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/testing/" class="category">Testing</a>
            (<span class="post-count">2</span>
            <a class="feed" href="/blog/testing/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/web/" class="category">Web</a>
            (<span class="post-count">1</span>
            <a class="feed" href="/blog/web/feed/"><i class="fa fa-rss"></i></a>)
          </li>
</ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Archives</div>
        <ul class="archives tw-space-y-2">
          
        <li>
            <a href="/blog/2023/" class="year">2023</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2022/" class="year">2022</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2021/" class="year">2021</a>
            (<span class="post-count">6</span>)
          </li>
<li>
            <a href="/blog/2020/" class="year">2020</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2016/" class="year">2016</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2015/" class="year">2015</a>
            (<span class="post-count">2</span>)
          </li>
<li>
            <a href="/blog/2014/" class="year">2014</a>
            (<span class="post-count">3</span>)
          </li>
<li>
            <a href="/blog/2013/" class="year">2013</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2012/" class="year">2012</a>
            (<span class="post-count">10</span>)
          </li>
<li>
            <a href="/blog/2011/" class="year">2011</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2010/" class="year">2010</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2009/" class="year">2009</a>
            (<span class="post-count">9</span>)
          </li>
</ul>

      </aside>

    </div>

    <footer class="page-footer">
      <p>© 2009 – <span class="current-year">2023</span> Tom Dalling</p>

      <p class="social">
        <a href="https://twitter.com/tom_dalling">
          <i class="fa fa-lg fa-twitter"></i>
        </a>
        <a href="https://github.com/tomdalling">
          <i class="fa fa-lg fa-github"></i>
        </a>
        <a href="https://stackoverflow.com/users/108105/tom-dalling">
          <i class="fa fa-lg fa-stack-overflow"></i>
        </a>
        <a href="mailto:tom%20at%20tomdalling%20com">
          <i class="fa fa-lg fa-envelope"></i>
        </a>
      </p>
    </footer>

    <script src="/bundles/all.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$$','$$']],
          displayMath: [['[blockmath]', '[/blockmath]']]
        }
      });
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  </body>
</html>
