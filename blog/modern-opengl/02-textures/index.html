<!DOCTYPE html>
<html lang="en">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7X96B4HGF4"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-7X96B4HGF4');
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Modern OpenGL 02 - Textures — Tom Dalling</title>
    <link rel="stylesheet" href="/style.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather+Sans:wght@700&amp;family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&amp;family=Montserrat:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

    <meta name="twitter:site" content="@tom_dalling">
    <meta name="twitter:creator" content="@tom_dalling">
    <link rel="alternate" type="application/rss+xml" title="Tom Dalling" href="https://www.tomdalling.com/blog/feed/">
  <link rel="canonical" href="https://www.tomdalling.com/blog/modern-opengl/02-textures/">
<meta property="og:title" content="Modern OpenGL 02 - Textures">
<meta property="og:url" content="https://www.tomdalling.com/blog/modern-opengl/02-textures/">
<meta property="og:image" content="https://www.tomdalling.com/images/posts/modern-opengl-02/main-image.png">
<meta name="twitter:card" content="summary_large_image">
</head>

  <body>

    <header class="tw-mb-6 tw-py-2 tw-bg-gray-100 tw-border-b tw-border-gray-200 tw-font-title">
      <nav class="tw-container tw-mx-auto tw-max-w-screen-xl tw-space-x-8 tw-px-4">
        <a href="/" class="tw-text-xl tw-text-black">Tom Dalling</a>
        <a href="/blog/" class="tw-text-black">Blog</a>
      </nav>
    </header>

    <div class="tw-container tw-mx-auto tw-flex tw-flex-col lg:tw-flex-row">

      <main class="tw-flex-1 tw-min-w-0 tw-px-4"><article class="post post-single">

  <header>
    <h1><a href="/blog/modern-opengl/02-textures/">Modern OpenGL 02 - Textures</a></h1>
    <small class="meta">
      <span class="post-date">02 Dec, 2012</span>
      
      —
      Category: <a class="category" href="/blog/category/modern-opengl/">Modern OpenGL Series</a>
      —
      Suggest changes <a class="post-github" href="https://github.com/tomdalling/tomdalling.com/tree/main/input/posts/2012-12-02_02-textures.markdown">on GitHub</a>
    </small>
    <div class="main-image">
      <img src="/images/posts/modern-opengl-02/main-image.png" class="img-responsive">
      
    </div>
  </header>

  <div class="post-content body-text">
<p>In this article, we will be adding a texture to the triangle. This will involve
adding new variables to the vertex and fragment shaders, creating and using
texture objects, and learning a bit about texture units and texture
coordinates.</p>

<p>This article introduces two new classes to the <code>tdogl</code> namespace:
<code>tdogl::Bitmap</code> and <code>tdogl::Texture</code>. These will allow us to load an image from
a jpg, png, or bmp file into video memory, for use in the shaders. Also, the
<code>tdogl::Program</code> class has some new methods for setting shader variables.</p>

<!--more-->
<p></p>
<div class="modern-opengl-preamble">
  <h2>Accessing The Code</h2>

  <p>
    Download all the code as a zip from here:
    <a href="https://github.com/tomdalling/opengl-series/archive/master.zip">
      https://github.com/tomdalling/opengl-series/archive/master.zip
    </a>
  </p>

  <p>
    All the code in this series of articles is available from github:
    <a href="https://github.com/tomdalling/opengl-series">https://github.com/tomdalling/opengl-series</a>.
    You can download a zip of all the files from that page, or you can clone the
    repository if you are familiar with git.
  </p>

  <p class="builds-on-previous">
    This article builds on the code from the previous article.
  </p>

  <p>
    The code for this article can be found in the
    <a class="source_folder" href="https://github.com/tomdalling/opengl-series/tree/master/source/02_textures">
      <code>source/02_textures</code>
    </a>
    folder. On OS X, open the <code>opengl-series.xcodeproj</code> file in the
    root folder, and select the target that corresponds with this article. On
    Windows, open the <code>opengl-series.sln</code> file in Visual Studio 2013,
    and open the project that corresponds with this article.
  </p>

  <p>
    The project includes all of its dependencies, so you shouldn't have to
    install or configure anything extra. Please let me know if you have
    any issues compiling and running the code.
  </p>
</div>


<h2>Uniform vs Attribute Shader Variables</h2>

<p>All the variables in the previous article were <em>attribute</em> variables. In this
article we will be introducing the other kind of variable: uniform variables.</p>

<blockquote class="pull-right">
  Attribute variables can have a different value for each vertex. Uniform
  variables keep the same value for multiple vertices.
</blockquote>

<p>There are two kinds of shader variables: <em>uniform</em> variables and <em>attribute</em>
variables. Attribute variables can have a different value for each vertex.
Uniform variables keep the same value for multiple vertices. For example, if
you want to set a colour for a whole triangle, you would use a uniform
variable. If you want each corner of a triangle to be a different color, you
would use an attribute variable. I will just refer to them as “uniforms” and
“attributes” from now on.</p>

<blockquote class="pull-right">
  Uniforms can be accessed from any shader, but attributes must enter the
  <em>vertex</em> shader first, not the <em>fragment</em> shader. The vertex
  shader can pass the value into the fragment shader if necessary.
</blockquote>

<p>Uniforms can be accessed from any shader, but attributes must enter the
<em>vertex</em> shader first, not the <em>fragment</em> shader. The vertex shader can pass
the value into the fragment shader if necessary. This is because uniforms are
like constants – they don’t change so they can be accessed from any
shader. However, attributes are not constant. The vertex shader can change the
value of an attribute before it gets to the fragment shader. The output of the
vertex shader is the input to the fragment shader.</p>

<p>To set the value of a uniform, we use one of the <a href="http://www.opengl.org/sdk/docs/man/xhtml/glUniform.xml">glUniform*</a> functions. To
set the value of an attribute, we store the values in a VBO and send them to
the shader with a VAO and <a href="http://www.opengl.org/sdk/docs/man/xhtml/glVertexAttribPointer.xml">glVertexAttribPointer</a> like we saw in the previous
article. It is also possible to set the value of an attribute using one of the
<a href="http://www.opengl.org/sdk/docs/man/xhtml/glVertexAttrib.xml">glVertexAttrib*</a> functions, if you are not storing the values in a VBO.</p>

<h2>Textures</h2>

<blockquote class="pull-right">
  Textures are basically 2D images that you can apply to your 3D objects.
</blockquote>

<p>Textures are basically 2D images that you can apply to your 3D objects. They
have other uses, but displaying a 2D image on 3D geometry is the most common
use. There are 1D, 2D and 3D textures, but we will only be looking at 2D
textures in this article. For a more in-depth look at textures, see the
<a href="http://www.arcsynthesis.org/gltut/Texturing/Tutorial%2014.html">Textures are not Pictures</a> chapter of the <a href="http://www.arcsynthesis.org/gltut/">Learning Modern 3D Graphics
Programming</a> book.</p>

<p>Textures live in video memory. That is, you upload the data for the texture to
the graphics card before you can use it. This is similar to how we saw VBOs
working in the previous article – VBOs are used to store data in video
memory before that data gets used.</p>

<blockquote class="pull-right">
  The pixel width and height of a texture should be a power of two.
</blockquote>

<p>The pixel width and height of a texture should be a power of two, for example:
16, 32, 64, 128, 256, 512. In this article we will use the 256x256 image
“hazard.png” as a texture, which is shown below.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-02/hazard.png">
  </figure>
</p>

<p>We will use the <code>tdogl::Bitmap</code> class to load the raw pixel data from
“hazard.png” into memory, with the help of <a href="https://github.com/nothings/stb">stb_image</a>. Then we will use
<code>tdogl::Texture</code> to upload the raw pixel data into an OpenGL texture object.
Fortunately, texture creation in OpenGL has not really changed since it was
first introduced, so there are plenty of good articles online that will show
you how to create a texture. The way that texture coordinates are sent to the
graphics card has changed, but the creation of the texture is the same.</p>

<p>Below is the constructor code for <code>tdogl::Texture</code>, which handles the creation
of an OpenGL texture.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Texture</span><span class="o">::</span><span class="n">Texture</span><span class="p">(</span><span class="k">const</span> <span class="n">Bitmap</span><span class="o">&amp;</span> <span class="n">bitmap</span><span class="p">,</span> <span class="n">GLint</span> <span class="n">minMagFiler</span><span class="p">,</span> <span class="n">GLint</span> <span class="n">wrapMode</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">_originalWidth</span><span class="p">((</span><span class="n">GLfloat</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">width</span><span class="p">()),</span>
    <span class="n">_originalHeight</span><span class="p">((</span><span class="n">GLfloat</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">height</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_object</span><span class="p">);</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">_object</span><span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">minMagFiler</span><span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">minMagFiler</span><span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">wrapMode</span><span class="p">);</span>
    <span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">wrapMode</span><span class="p">);</span>
    <span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span>
                 <span class="mi">0</span><span class="p">,</span> 
                 <span class="n">TextureFormatForBitmapFormat</span><span class="p">(</span><span class="n">bitmap</span><span class="p">.</span><span class="n">format</span><span class="p">()),</span>
                 <span class="p">(</span><span class="n">GLsizei</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">width</span><span class="p">(),</span> 
                 <span class="p">(</span><span class="n">GLsizei</span><span class="p">)</span><span class="n">bitmap</span><span class="p">.</span><span class="n">height</span><span class="p">(),</span>
                 <span class="mi">0</span><span class="p">,</span> 
                 <span class="n">TextureFormatForBitmapFormat</span><span class="p">(</span><span class="n">bitmap</span><span class="p">.</span><span class="n">format</span><span class="p">()),</span> 
                 <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> 
                 <span class="n">bitmap</span><span class="p">.</span><span class="n">pixelBuffer</span><span class="p">());</span>
    <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2>Texture Coordinates</h2>

<blockquote class="pull-right">
  The strange thing about texture coordinates is that they are not in pixels.
  They range from zero to one, where (0,0) is the bottom left and (1,1) is the
  top right.
</blockquote>

<p>Texture coordinates are, unsurprisingly, coordinates on a texture. The strange
thing about texture coordinates is that they are not in pixels. They range from
zero to one, where (0,0) is the bottom left and (1,1) is the top right. If you
load the image into OpenGL upside down, then (0,0) will be the top left, not
the bottom left. To turn pixel coordinates into texture coordinates, you must
divide by the width and height of the texture. For example, in a 256x256 image,
the pixel coordinates (128, 256) become (0.5, 1) in texture coordinates.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-02/uv_coords.png">
  </figure>
</p>

<p>Texture coordinates are commonly referred to as UV coordinates. You could call
them XY coordinates, but XYZ is commonly used to represent a vertex, and we
don’t want to confuse texture coordinates with vertex coordinates.</p>

<h2>Texture Image Units</h2>

<blockquote class="pull-right">
  You can't just send a texture straight to a shader. First you bind the
  texture to a texture unit, then you send the <em>index of the texture
  unit</em> to the shader.
</blockquote>

<p>Texture image units, or just “texture units” for short, are a slightly weird
part of OpenGL. You can’t just send a texture straight to a shader. First you
bind the texture to a texture unit, then you send the <em>index of the texture
unit</em> to the shader.</p>

<p>There are a limited number of texture units. On less-powerful devices such as
phones, there might only be two texture units. In that case, even though we
could have dozens of textures, we could only use two of them at the same time
in the shaders. We will only be using one texture in this article, so we only
need one texture unit, but it is possible to blend multiple different textures
together inside the fragment shader.</p>

<h2>Implementing Textures</h2>

<p>First, let’s make a new global for the texture.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tdogl</span><span class="o">::</span><span class="n">Texture</span><span class="o">*</span> <span class="n">gTexture</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div>

<p>We’ll make a new function to load “hazard.png” into the global. This gets
called from the <code>AppMain</code> function.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">LoadTexture</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">tdogl</span><span class="o">::</span><span class="n">Bitmap</span> <span class="n">bmp</span> <span class="o">=</span> <span class="n">tdogl</span><span class="o">::</span><span class="n">Bitmap</span><span class="o">::</span><span class="n">bitmapFromFile</span><span class="p">(</span><span class="n">ResourcePath</span><span class="p">(</span><span class="s">"hazard.png"</span><span class="p">));</span>
    <span class="n">bmp</span><span class="p">.</span><span class="n">flipVertically</span><span class="p">();</span>
    <span class="n">gTexture</span> <span class="o">=</span> <span class="k">new</span> <span class="n">tdogl</span><span class="o">::</span><span class="n">Texture</span><span class="p">(</span><span class="n">bmp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next we will give each vertex of the triangle a texture coordinate. If you
compare the UV coords to the image above, you will see that the coordinates
represent (middle,top), (left,bottom), and (right,bottom) in that order.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GLfloat</span> <span class="n">vertexData</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">//  X     Y     Z       U     V</span>
     <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
     <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Now we need to modify the fragment shader so that it takes a texture and a
texture coordinate as input. The new fragment shader looks like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#version 150
</span><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">tex</span><span class="p">;</span> <span class="c1">//this is the texture</span>
<span class="n">in</span> <span class="n">vec2</span> <span class="n">fragTexCoord</span><span class="p">;</span> <span class="c1">//this is the texture coord</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">finalColor</span><span class="p">;</span> <span class="c1">//this is the output color of the pixel</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">finalColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">tex</span><span class="p">,</span> <span class="n">fragTexCoord</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code>uniform</code> keyword indications that <code>tex</code> is a <em>uniform</em> variable. The
texture is a uniform because all the vertices of the triangle will have the
same texture. <code>sampler2D</code> is the variable type, indicating that it holds a 2D
texture.</p>

<p>The <code>fragTexCoord</code> is an <em>attribute</em> variable, because each vertex of the
triangle will have a different texture coordinate.</p>

<p>The <code>texture</code> function finds the color of the pixel at the given texture
coordinate. In older versions of GLSL, you would use the <code>texture2D</code> function
to do this.</p>

<p>We can’t pass an attribute straight into the fragment shader, because
attributes must first go through the vertex shader. Here is the modified vertex
shader:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#version 150
</span><span class="n">in</span> <span class="n">vec3</span> <span class="n">vert</span><span class="p">;</span>
<span class="n">in</span> <span class="n">vec2</span> <span class="n">vertTexCoord</span><span class="p">;</span>
<span class="n">out</span> <span class="n">vec2</span> <span class="n">fragTexCoord</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Pass the tex coord straight through to the fragment shader</span>
    <span class="n">fragTexCoord</span> <span class="o">=</span> <span class="n">vertTexCoord</span><span class="p">;</span>
    
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">vert</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This vertex shader takes <code>vertTexCoord</code> as input, and passes it straight into
the <code>fragTexCoord</code> attribute of the fragment shader without modifying it.</p>

<p>The shaders now have two variables we need to set: the <code>vertTexCoord</code> attribute
and <code>tex</code> uniform. Let’s start by setting the <code>tex</code> variable. Open up main.cpp
and find the <code>Render()</code> function. We will set the <code>tex</code> uniform just before we
draw the triangle:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">gTexture</span><span class="o">-&gt;</span><span class="n">object</span><span class="p">());</span>
<span class="n">gProgram</span><span class="o">-&gt;</span><span class="n">setUniform</span><span class="p">(</span><span class="s">"tex"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//set to 0 because the texture is bound to GL_TEXTURE0</span>
</code></pre></div></div>

<p>The texture can’t be used until it is bound to a texture unit.
<code>glActiveTexture</code> tells OpenGL which texture unit we want to use. <code>GL_TEXTURE0</code>
is the first texture unit, so we will just use that.</p>

<p>Next, we use <code>glBindTexture</code> bind our texture into the active texture unit.</p>

<p>Then we set the <code>tex</code> uniform of the shaders to the <em>index of the texture
unit</em>. We used texture unit zero, so we set the <code>tex</code> uniform to the integer
value <code>0</code>. The <code>setUniform</code> method just calls the <code>glUniform1i</code> function.</p>

<p>The final step is to get the texture coordinates into the <code>vertTexCoord</code>
attribute. To do this, we will modify the VAO inside the <code>LoadTriangle()</code>
function. This is what the code used to look like:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Put the three triangle vertices into the VBO</span>
<span class="n">GLfloat</span> <span class="n">vertexData</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">//  X     Y     Z</span>
     <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
     <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span>
<span class="p">};</span>

<span class="c1">// connect the xyz to the "vert" attribute of the vertex shader</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">gProgram</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vert"</span><span class="p">));</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">gProgram</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vert"</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>

<p>And this is what we need to change it to:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Put the three triangle vertices (XYZ) and texture coordinates (UV) into the VBO</span>
<span class="n">GLfloat</span> <span class="n">vertexData</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">//  X     Y     Z       U     V</span>
     <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
     <span class="mf">0.8</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">0.8</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// connect the xyz to the "vert" attribute of the vertex shader</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">gProgram</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vert"</span><span class="p">));</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">gProgram</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vert"</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
    
<span class="c1">// connect the uv coords to the "vertTexCoord" attribute of the vertex shader</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">gProgram</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vertTexCoord"</span><span class="p">));</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">gProgram</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vertTexCoord"</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">,</span>  <span class="mi">5</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">)));</span>
</code></pre></div></div>

<p>We’ve added a second call to <code>glVertexAttribPointer</code>, but we’ve also modified
the first call as well. The most important arguments to look at are the last
two.</p>

<p>The second last argument to both <code>glVertexAttribPointer</code> calls is
<code>5*sizeof(GLfloat)</code>. This is the “stride” argument. This argument wants to know
how many bytes are between the start of one value, and the start of the next
value. In both cases, each value is five <code>GLfloat</code>s away from the next value.
For example, if we start at the “X” value and count forward five values, we
will be at the next “X” value. The same is true if we start at a “U” value, and
count forward five. This argument is in <em>bytes</em>, not floats, so we must
multiply the number of floats by the number of bytes per float.</p>

<p>The last argument to <code>glVertexAttribPointer</code> is the “offset” argument. This
argument wants to know how many bytes from the start is the first value. The
first <strong>XYZ</strong> value is right at the beginning, so the offset is set to NULL
which means “zero bytes from the start”. The first <strong>UV</strong> value is not at the
beginning – it is three floats away from the beginning. Once again, this
argument is in <em>bytes</em>, not floats, so we must multiply the number of floats by
the number of bytes per float. We must cast the number of bytes to a <code>const
GLvoid*</code>, because in older versions of OpenGL this argument used to be
something different to the “offset” that it is now.</p>

<p>Now, when you run the program, you should see a textured triangle like the one
shown at the top of this article.</p>

<h2>Future Article Sneak Peek</h2>

<p>In the next article we will learn a bit about matrix math, and use matrices to
spin a cube, move the camera, and add a perspective projection. We will also
learn about depth buffering, and how a typical program does time-based updates
such as animation.</p>

<h2>Additional OpenGL Texture Resources</h2>

<ul>
  <li><a href="http://www.opengl.org/wiki/Texture">The texture page on the OpenGL wiki</a></li>
  <li>
<a href="http://www.arcsynthesis.org/gltut/Texturing/Texturing.html">The texturing chapters</a> of the Learning Modern 3D Graphics Programming book.</li>
  <li>
<a href="http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html">Tutorial 16 - Basic Texture Mapping</a> by Etay Meiri</li>
  <li>
<a href="https://github.com/progschj/OpenGL-Examples/blob/master/03texture.cpp">The texturing example code</a> by Jakob Progsch</li>
</ul>

<h2>Translations Of This Article</h2>
<ul>
  <li><a href="http://science.webhostinggeeks.com/Moderne-OpenGL02%E2%80%93Teksture">Serbo-Croatian</a></li>
</ul>

</div>

  <footer>
    <div class="tw-rounded-3xl tw-bg-pink-100 tw-p-8 tw-my-16 tw-text-center tw-bg-opacity-50">
      <p class="tw-text-2xl tw-uppercase tw-text-pink-900 tw-font-black tw-mb-4">Enjoy this?</p>

      <p class="tw-flex tw-flex-col sm:tw-flex-row tw-justify-center tw-item-center sm:tw-items-baseline">
        <a href="/feed/" class="tw-flex-1 tw-bg-pink-500 tw-py-3 tw-px-4 tw-rounded-lg tw-text-pink-100 tw-ring-2 tw-ring-pink-300 tw-max-w-52 hover:tw-text-white">Subscribe via RSS</a>
      </p>

      <p class="tw-text-center tw-mt-4 tw-mb-0 tw-text-pink-900">
        <em>Found a mistake?</em> Pull requests are welcome on
        <a href="https://github.com/tomdalling/tomdalling.com">GitHub</a>.
      </p>
</div>

    


    
      <h2>Comments</h2>
      <div id="disqus_thread"></div>
      <script type="text/javascript" id="disqus_script">
        var disqus_shortname = "tomdalling";
        var disqus_identifier = "821 http://tomdalling.com/?p=821";
        var disqus_title = "Modern OpenGL 02 - Textures";
        var disqus_url = "https://www.tomdalling.com/blog/modern-opengl/02-textures/";

        (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments.</a>
</noscript>
    

  </footer>
</article>
</main>

      <aside class="tw-px-4 tw-text-center lg:tw-text-left lg:tw-w-1/3 tw-flex-none">

        <div class="tw-text-lg tw-font-title tw-mb-1">Subscribe</div>
        <ul class="tw-space-y-2">
          <li>
            <a href="/blog/feed/">
              <i class="fa fa-rss"></i> RSS
            </a>
          </li>
        </ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Recent Posts</div>
        <ul class="recent-posts tw-space-y-2">
          
        <li><a href="/blog/software-processes/against-must-haves-part-three/">Against Must-Haves (Part Three)</a></li>
<li><a href="/blog/software-processes/high-performance-requires-process/">High Performance Requires Process</a></li>
<li><a href="/blog/software-processes/ditch-the-umbrella-and-grab-some-sunnies/">Ditch The Umbrella And Grab Some Sunnies</a></li>
<li><a href="/blog/software-processes/nugs-and-negative-failure-demand/">Nugs And Negative Failure Demand</a></li>
<li><a href="/blog/software-processes/against-must-haves-part-two/">Against Must-Haves (Part Two)</a></li>
</ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Categories</div>
        <ul class="categories tw-space-y-2">
          
        <li>
            <a href="/blog/cocoa/" class="category">Cocoa</a>
            (<span class="post-count">5</span>
            <a class="feed" href="/blog/cocoa/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/coding-styleconventions/" class="category">Coding Style/Conventions</a>
            (<span class="post-count">3</span>
            <a class="feed" href="/blog/coding-styleconventions/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/coding-tips/" class="category">Coding Tips</a>
            (<span class="post-count">4</span>
            <a class="feed" href="/blog/coding-tips/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/mentoring/" class="category">Mentoring Notes</a>
            (<span class="post-count">3</span>
            <a class="feed" href="/blog/mentoring/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/random-stuff/" class="category">Miscellaneous</a>
            (<span class="post-count">4</span>
            <a class="feed" href="/blog/random-stuff/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/modern-opengl/" class="category">Modern OpenGL Series</a>
            (<span class="post-count">10</span>
            <a class="feed" href="/blog/modern-opengl/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/ruby/" class="category">Ruby</a>
            (<span class="post-count">2</span>
            <a class="feed" href="/blog/ruby/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/software-design/" class="category">Software Design</a>
            (<span class="post-count">12</span>
            <a class="feed" href="/blog/software-design/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/software-processes/" class="category">Software Processes</a>
            (<span class="post-count">10</span>
            <a class="feed" href="/blog/software-processes/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/testing/" class="category">Testing</a>
            (<span class="post-count">2</span>
            <a class="feed" href="/blog/testing/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/web/" class="category">Web</a>
            (<span class="post-count">1</span>
            <a class="feed" href="/blog/web/feed/"><i class="fa fa-rss"></i></a>)
          </li>
</ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Archives</div>
        <ul class="archives tw-space-y-2">
          
        <li>
            <a href="/blog/2025/" class="year">2025</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2024/" class="year">2024</a>
            (<span class="post-count">2</span>)
          </li>
<li>
            <a href="/blog/2023/" class="year">2023</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2022/" class="year">2022</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2021/" class="year">2021</a>
            (<span class="post-count">6</span>)
          </li>
<li>
            <a href="/blog/2020/" class="year">2020</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2016/" class="year">2016</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2015/" class="year">2015</a>
            (<span class="post-count">2</span>)
          </li>
<li>
            <a href="/blog/2014/" class="year">2014</a>
            (<span class="post-count">3</span>)
          </li>
<li>
            <a href="/blog/2013/" class="year">2013</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2012/" class="year">2012</a>
            (<span class="post-count">10</span>)
          </li>
<li>
            <a href="/blog/2011/" class="year">2011</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2010/" class="year">2010</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2009/" class="year">2009</a>
            (<span class="post-count">9</span>)
          </li>
</ul>

      </aside>

    </div>

    <footer class="page-footer">
      <p>© 2009 – <span class="current-year">2025</span> Tom Dalling</p>

      <p class="social">
        <a href="https://github.com/tomdalling">
          <i class="fa fa-lg fa-github"></i>
        </a>
        <a href="https://stackoverflow.com/users/108105/tom-dalling">
          <i class="fa fa-lg fa-stack-overflow"></i>
        </a>
        <a href="mailto:tom%20at%20tomdalling%20com">
          <i class="fa fa-lg fa-envelope"></i>
        </a>
      </p>
    </footer>

    <script src="/bundles/all.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$$','$$']],
          displayMath: [['[blockmath]', '[/blockmath]']]
        }
      });
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  </body>
</html>
