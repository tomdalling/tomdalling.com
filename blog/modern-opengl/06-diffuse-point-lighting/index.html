<!DOCTYPE html>
<html lang="en">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7X96B4HGF4"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-7X96B4HGF4');
    </script>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Modern OpenGL 06 – Diffuse Point Lighting — Tom Dalling</title>
    <link rel="stylesheet" href="/style.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Merriweather+Sans:wght@700&amp;family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&amp;family=Montserrat:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

    <meta name="twitter:site" content="@tom_dalling">
    <meta name="twitter:creator" content="@tom_dalling">
    <link rel="alternate" type="application/rss+xml" title="Tom Dalling" href="https://www.tomdalling.com/blog/feed/">
  <link rel="canonical" href="https://www.tomdalling.com/blog/modern-opengl/06-diffuse-point-lighting/">
<meta property="og:title" content="Modern OpenGL 06 – Diffuse Point Lighting">
<meta property="og:url" content="https://www.tomdalling.com/blog/modern-opengl/06-diffuse-point-lighting/">
<meta property="og:image" content="https://www.tomdalling.com/images/posts/modern-opengl-06/main-image.png">
<meta name="twitter:card" content="summary_large_image">
</head>

  <body>

    <header class="tw-mb-6 tw-py-2 tw-bg-gray-100 tw-border-b tw-border-gray-200 tw-font-title">
      <nav class="tw-container tw-mx-auto tw-max-w-screen-xl tw-space-x-8 tw-px-4">
        <a href="/" class="tw-text-xl tw-text-black">Tom Dalling</a>
        <a href="/blog/" class="tw-text-black">Blog</a>
      </nav>
    </header>

    <div class="tw-container tw-mx-auto tw-flex tw-flex-col lg:tw-flex-row">

      <main class="tw-flex-1 tw-min-w-0 tw-px-4"><article class="post post-single">

  <header>
    <h1><a href="/blog/modern-opengl/06-diffuse-point-lighting/">Modern OpenGL 06 – Diffuse Point Lighting</a></h1>
    <small class="meta">
      <span class="post-date">23 Mar, 2013</span>
      
      —
      Category: <a class="category" href="/blog/category/modern-opengl/">Modern OpenGL Series</a>
      —
      Suggest changes <a class="post-github" href="https://github.com/tomdalling/tomdalling.com/tree/main/input/posts/2013-03-23_06-diffuse-point-lighting.markdown">on GitHub</a>
    </small>
    <div class="main-image">
      <img src="/images/posts/modern-opengl-06/main-image.png" class="img-responsive">
      
    </div>
  </header>

  <div class="post-content body-text">
<p>This is the first article covering lighting. We will begin our lighting
adventure by implementing per-pixel, diffuse lighting with a single point
light. In later articles we will implement ambient and specular reflection,
directional lights, spotlights, attenuation, and using multiple lights.</p>

<!--more-->

<div class="modern-opengl-preamble">
  <h2>Accessing The Code</h2>

  <p>
    Download all the code as a zip from here:
    <a href="https://github.com/tomdalling/opengl-series/archive/master.zip">
      https://github.com/tomdalling/opengl-series/archive/master.zip
    </a>
  </p>

  <p>
    All the code in this series of articles is available from github:
    <a href="https://github.com/tomdalling/opengl-series">https://github.com/tomdalling/opengl-series</a>.
    You can download a zip of all the files from that page, or you can clone the
    repository if you are familiar with git.
  </p>

  <p class="builds-on-previous">
    This article builds on the code from the previous article.
  </p>

  <p>
    The code for this article can be found in the
    <a class="source_folder" href="https://github.com/tomdalling/opengl-series/tree/master/source/06_diffuse_lighting">
      <code>source/06_diffuse_lighting</code>
    </a>
    folder. On OS X, open the <code>opengl-series.xcodeproj</code> file in the
    root folder, and select the target that corresponds with this article. On
    Windows, open the <code>opengl-series.sln</code> file in Visual Studio 2013,
    and open the project that corresponds with this article.
  </p>

  <p>
    The project includes all of its dependencies, so you shouldn't have to
    install or configure anything extra. Please let me know if you have
    any issues compiling and running the code.
  </p>
</div>


<h2>Keyboard Controls For This Article</h2>

<table class="table table-hover table-bordered">
  <tbody>
    <tr>
      <td><kbd>W</kbd></td>
      <td>Move forward</td>
    </tr>
    <tr>
      <td><kbd>A</kbd></td>
      <td>Move left</td>
    </tr>
    <tr>
      <td><kbd>S</kbd></td>
      <td>Move backward</td>
    </tr>
    <tr>
      <td><kbd>D</kbd></td>
      <td>Move right</td>
    </tr>
    <tr>
      <td><kbd>X</kbd></td>
      <td>Move up</td>
    </tr>
    <tr>
      <td><kbd>Z</kbd></td>
      <td>Move down</td>
    </tr>
  </tbody>
</table>

<table class="table table-hover table-bordered">
  <tbody>
    <tr>
      <td><kbd>1</kbd></td>
      <td>Set light position to camera position</td>
    </tr>
    <tr>
      <td><kbd>2</kbd></td>
      <td>Set light intensities to green</td>
    </tr>
    <tr>
      <td><kbd>3</kbd></td>
      <td>Set light intensities to red</td>
    </tr>
    <tr>
      <td><kbd>4</kbd></td>
      <td>Set light intensities to white</td>
    </tr>
  </tbody>
</table>

<h2>Point Lights</h2>

<blockquote class="pull-right">
  Point lights radiate light outwards in all directions from a single point,
  much like a candle.
</blockquote>

<p>In this article, we will be implementing a type of light called a <em>point
light</em>. Point lights radiate light outwards in all directions from a single
point, much like a candle. If you look at the screenshot at the top of this
article, it looks like an invisible candle is being held up to the wooden
crates.</p>

<p>There are other common types of lights, such as directional lights and
spotlights, but we will cover those in a later article.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/point-light.jpg">
    <figcaption>
      Image by <a href="http://commons.wikimedia.org/wiki/File:Teelicht_2009.JPG">4028mdk09</a>
    </figcaption>
  </figure>
</p>

<h2>Phong Reflection Model</h2>

<blockquote class="pull-right">
  The Phong reflection model provides a method of calculating the color of a
  pixel, based on the parameters of a light source and a surface.
</blockquote>

<p>We will be implementing the diffuse component of the <a href="http://en.wikipedia.org/wiki/Phong_reflection_model">Phong reflection
model</a>. The Phong reflection model provides a method of calculating the color
of a pixel, based on the parameters of a light source and a surface. The light
source parameters include the position/direction of the light, and the
color/intensity of the light. The surface parameters include the color of the
surface, the direction the surface is facing (a.k.a the normal), and the
“shininess” of the surface.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/800px-Phong_components_version_4.png">
    <figcaption>
      Image by <a href="http://en.wikipedia.org/wiki/File:Phong_components_version_4.png">Brad Smith</a>.
    </figcaption>
  </figure>
</p>

<p>The Phong reflection model has three components: ambient, diffuse, and
specular. The diffuse component is the most important one, as you can see from
the image above. The ambient component is used to stop the unlit, back sides of
objects from being pure black, because pure black looks artificial in most 3D
scenes. The specular component is what makes an object look shiny or dull.
Because we’re only implementing the diffuse component in this article, the
wooden crates will be pure black on the back sides, and can not be shiny. We
will implement the ambient and specular components in the next couple of
articles.</p>

<h2>Light Intensities</h2>

<p>The Phong reflection model is loosely based on the way that light behaves in
the real world. So, in order to understand lighting in OpenGL, we have to
understand a little bit about the physics of light – not a lot, but just enough
to make our 3D scene look more realistic.</p>

<blockquote class="pull-right">
  White light contains all the colors.
</blockquote>

<p>White light contains all the colors that our human eyes can see. This can be
demonstrated by shining a white light into a prism, which makes the light split
into a rainbow.</p>

<figure class="nopadding black">
  <img src="/images/posts/modern-opengl-06/Dispersion_prism.jpg">
</figure>

<p>Another way to demonstrate this is by getting three different colors of light –
red, green and blue – and shining them onto a white surface in a dark room. If
you were to do this, you would see the image below.</p>

<figure class="black">
  <img src="/images/posts/modern-opengl-06/rgb-light2.png">
</figure>

<p>We can draw some conclusions from this:</p>

<ul>
  <li>White = red + green + blue</li>
  <li>Yellow = red + green</li>
  <li>Cyan (light blue) = blue + green</li>
  <li>Magenta (purply-pink) = red + blue</li>
  <li>Black = none of the colors</li>
</ul>

<p>Using only three colors of light, we can make eight different colors: red,
green, blue, yellow, cyan, magenta, black and white.</p>

<p>But what about the other colors, like orange? Well, if you take the green light
and make it <strong>half as bright</strong> as it used to be, you would see the image below.</p>

<figure class="black">
  <img src="/images/posts/modern-opengl-06/rgb-light2-half-green.png">
</figure>

<p>Lowering the intensity (a.k.a. brightness) of the green has made a few new
colors: dark green, sky blue, orange, and pink.</p>

<blockquote class="pull-right">
  Colors are combinations of different intensities of red, green and blue
  light.
</blockquote>

<blockquote class="pull-right">
  The color of a light is called the <em>intensities</em> of the light.
</blockquote>

<p>As you can see, colors are combinations of different intensities of red, green
and blue light. This is why the color of a light is called the <em>intensities</em> of
the light. When we set the color of the light in the code, we will be using a
<code>vec3</code> to hold the red, green and blue intensities.</p>

<h2>Absorption &amp; Reflection Of Color</h2>

<p>Let’s say you’re looking at a red car. The sun emits a ray of white light. The
ray bounces off the car, and goes into your eye. Your eye detects that the ray
only contains red light, which is why you see a red car instead of a white car.
We know that white light contains all colors, so what happened to the green and
blue? The green and blue light was <strong>absorbed</strong> by the surface, and the red
light was <strong>reflected</strong>.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/red-reflectance.png">
  </figure>
</p>

<p>What if we were to shine a pure cyan (blue + green) light on the red car? If
the car was pure red, it would look <em>black</em>, because it would absorb 100% of
the light.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/red-reflectance-of-cyan.png">
  </figure>
</p>

<p>What about a cyan (blue + green) light on a magenta (red + blue) surface?</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/magenta-reflectance-of-cyan.png">
  </figure>
</p>

<p>So if you shine a light-blue flashlight onto a purply-pink surface, the surface
will appear to be dark blue. It’s strange, but true.</p>

<blockquote class="pull-right">
  The RGB color of a surface represents how light is absorbed and reflected by
  that surface.
</blockquote>

<p>If you look at the RGB value of each color, you will notice that the values
represent reflectance. (0,0,0) is black, which means <em>reflect none of the
light</em>. (1,1,1) is white, which means <em>reflect all of the light</em>. (1,0,0) is
red, which means <em>only reflect the red</em>. Cyan is (0,1,1), which means <em>only
reflect blue and green</em>. The RGB color of a surface represents how light is
absorbed and reflected by that surface.</p>

<p>Calculating the reflected color is simple. The basic formula is: <code>intensities
× surface color = reflected intensities</code>. For example:</p>

<pre><code>cyan light × magenta surface = blue light
(0, 1, 1)  × (1, 0, 1)       = (0, 0, 1)
</code></pre>

<p>The multiplication is done by multiplying each of the RGB components
individually, like so:</p>

<p>
  <figure>
    [blockmath] (X, Y, Z) (A,B,C) = (XA, YB, ZC) [/blockmath]
  </figure>
</p>

<h2>Angle of Incidence</h2>

<p>Here is a lovely animation of me spinning a notepad in front of a light:</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/angle_of_incidence_anim.gif">
  </figure>
</p>

<p>This animation demonstrates how the <em>angle of incidence</em> (AoI) of the light
affects the color of the surface (the notepad). Notice how the notepad is
brightest when it is facing the light front-on. As the notepad rotates away
from it’s brightest position, the surface gets darker.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/angle_of_incidence_comparison2.jpg">
  </figure>
</p>

<blockquote class="pull-right">
  The angle at which the rays of light hit the surface is called the <em>angle
  of incidence</em> (AoI). The angle of incidence affects the brightness of a
  surface.
</blockquote>

<p>The angle at which the rays of light hit the surface is called the <em>angle of
incidence</em> (AoI). The angle of incidence affects the brightness of the surface.
The AoI is the basis of diffuse reflection, which we will implement in this
article.</p>

<p>Let’s look at the the AoI at the two extremes: maximum brightness and complete
darkness.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/aoi_min_max.png">
  </figure>
</p>

<p>Maximum brightness occurs when the surface is <em>perpendicular</em> to the light rays
(AoI = 0°). Complete darkness occurs when the surface is <em>parallel</em> to the
light rays (AoI = 90°). If the AoI is greater than 90°, then the ray is
hitting the <em>back</em> of the surface. If light is hitting the back, then it’s
definitely not hitting the front, so the pixel should also be completely dark.</p>

<p>If we represent the brightness as a single number, where 0.0 is completely dark
and 1.0 is maximum brightness, then it’s easy to calculate based on the cosine
of the AoI. The formula is <code>brightness = cos(AoI)</code>. Let’s have a look at the
cosine of some angles, just to prove that it works:</p>

<pre><code>cos(  0°) =  1.00 (100% of maximum brightness)
cos(  5°) =  0.98 ( 98% of maximum brightness)
cos( 45°) =  0.71 ( 71% of maximum brightness)
cos( 85°) =  0.09 (  9% of maximum brightness)
cos( 90°) =  0.00 (Completely dark)
cos(100°) = -0.17 (Completely dark. Negative value means light is hitting the back side)
</code></pre>

<p>Once we have a brightness value between 0 and 1, we can multiply it by the
intensities of the reflected light to get the final color for the pixel. Here
is an example with cyan light:</p>

<pre><code>brightness × light intensities = final color for pixel
1.0 × (0, 1, 1) = (0, 1, 1) (cyan, unchanged)
0.5 × (0, 1, 1) = (0, 0.5, 0.5) (turquoise, which is darkened cyan)
0.0 × (0, 1, 1) = (0, 0, 0) (black)
</code></pre>

<p>This “brightness” value between 0 and 1 is sometimes called the “diffuse
coefficient.”</p>

<h2>Surface Normals</h2>

<blockquote class="pull-right">
  Normals are unit vectors that are perpendicular (at right angle, 90°) to
  a surface.
</blockquote>

<p>In order to calculate the AoI, we first need to know the direction that each
surface is facing. The direction that a surface is facing is called the
<em>normal</em> of that surface. Normals are unit vectors that are perpendicular (at
right angle, 90°) to a surface.</p>

<p>The angle of incidence is defined as the angle between the surface normal, and
the direction to the light source.</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/normal_aoi.png">
    <figcaption>
        <em>N</em> = the surface normal vector<br>
        <em>L</em> = a vector from the surface to the light source<br>
        <em>θ</em> = the angle of incidence
    </figcaption>
  </figure>
</p>

<p>The vector from the surface to the light source, <em>L</em>, can be calculated with
vector subtraction, like so:</p>

<p>
  <figure>
    [blockmath] L = lightPosition - surfacePosition [/blockmath]
  </figure>
</p>

<p>You may wish to read <a href="/blog/modern-opengl/04-cameras-vectors-and-input/">article 04</a> of this series if you need to brush up on
vector math.</p>

<p>The surface normal is usually supplied from the VBO, the same way the vertex
and texture coordinates are supplied. When we get to the code for this article,
we will be adding a normal for each vertex in the VBO.</p>

<h2>Calculating The Angle Between Two Vectors: The Dot Product</h2>

<blockquote class="pull-right">
  It is possible to calculate the angle between two vectors using the <em>dot
  product</em> of the vectors.
</blockquote>

<p>It is possible to calculate the angle between two vectors using the <em>dot
product</em> of the vectors. The dot product is an operation that takes two
vectors, and results in a single number (a scalar). Shockingly, the dot product
looks like a dot in mathematical notation: $$\vec{v_1}\bullet\vec{v_2}$$. In
GLSL and GLM, it is a function called “dot”: <code>dot(v1, v2)</code>, and <code>glm::dot(v1,
v2)</code>.</p>

<p>The result of the dot product is related to the angle between the two vectors.
The exact relationship is:</p>

<p>
  <figure>
    [blockmath]
      \begin{align}
        \vec {v_1} \bullet \vec {v_2} &amp;= \|\vec {v_1}\|\|\vec {v_2}\|cos(\theta) \\\\
        \frac{\vec {v_1} \bullet \vec {v_2}}{\|\vec {v_1}\|\|\vec {v_2}\|} &amp;= cos(\theta) \\\\
        cos^{-1}\left(\frac{\vec {v_1} \bullet \vec {v_2}}{\|\vec {v_1}\|\|\vec {v_2}\|}\right) &amp;= \theta
      \end{align}
    [/blockmath]
  </figure>
</p>

<p>Where $$\vec{v_1}$$ and $$\vec{v_2}$$ are vectors, $$\theta$$ is the angle
between the two vectors, and $$|\vec v|$$ is the magnitude of $$\vec v$$.</p>

<p>The exact same thing, written like code, looks like this:</p>

<pre><code>                              dot(v1,v2) == length(v1)*length(v2)*cos(angle)
      dot(v1,v2)/(length(v1)*length(v2)) == cos(angle)
acos(dot(v1,v2)/(length(v1)*length(v2))) == angle
</code></pre>

<p><code>length</code> is a GLSL function that returns the magnitude of a vector.</p>

<p>We don’t actually need to know the AoI, we just need <code>cos(AoI)</code>, which
represents brightness. The brightness calculation in the fragment shader is
based on the middle line of the formulas above.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//    cos(angle) = dot(v1, v2)                 / (length(v1) * length(v2))</span>
<span class="kt">float</span> <span class="n">brightness</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">surfaceToLight</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">surfaceToLight</span><span class="p">)</span> <span class="o">*</span> <span class="nf">length</span><span class="p">(</span><span class="n">normal</span><span class="p">));</span>
</code></pre></div></div>

<h2>Matrix Transformation Of Normals</h2>

<p>Normals are usually provided in <em>model space</em>, which means they are relative to
the vertices of the asset before any transformations have been applied.
However, when we calculate the vector from the surface to the light, that is
done in <em>world space</em>. World space is where all the 3D objects have been
positioned/scaled/rotated into their places inside the 3D scene. For example,
in model space, the center of our wooden crate asset is (0,0,0). After we
position and resize the crates to spell out “Hi” in the 3D scene, those crates
are in world space. The transformation from model space to world space is done
by the “model matrix” of each instance in the scene, which is the
<code>ModelInstance::transform</code> variable in the code for this article.</p>

<blockquote class="pull-right">
  When we transform the vertices of an asset, we also have to transform the
  normals.
</blockquote>

<p>When vertices are transformed from model space to world space, they may have
been rotated. If the vertices of a surface have been rotated, then the surface
now faces a different direction, so the normal of the surface will be
different. This means that when we transform the vertices of an asset, we also
have to transform the normals.</p>

<blockquote class="pull-right">
  Scaling or translating a normal will result in an incorrect normal.
</blockquote>

<p>So far, we’ve only used matrices to transform coordinates. The problem is that
normals are <em>not</em> coordinates, they are unit vectors representing directions.
Rotation transformations are fine, because the rotating a unit vector results
in another unit vector, but scaling or translating a normal will result in an
incorrect normal. The solution is to multiply the normals by a different matrix
– one that has the translation and scaling parts fixed.</p>

<p>Removing the translation part of a 4x4 matrix is simple: we just remove the
4<sup>th</sup> column and row, converting it to a 3x3 matrix. Fixing the
scaling is a bit trickier, but I’ll jump straight to the answer, which is to
invert and transpose the matrix. We will also need to renormalise each normal
after it has been transformed, to ensure that it is still a unit vector. The
GLSL to do this looks like:</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">mat3</span> <span class="n">normalMatrix</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="kt">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)));</span>
<span class="kt">vec3</span> <span class="n">transformedNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span> <span class="o">*</span> <span class="n">normal</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code>model</code> variable is the original 4x4 model transformation matrix. The
<code>mat3</code> function removes the translation part of the matrix. The <code>inverse</code> and
<code>transpose</code> functions will fix up the scaling part. Finally, after we transform
the original normal with <code>normalMatrix * normal</code>, the <code>normalize</code> function will
ensure that the transformed normal is a unit vector.</p>

<div class="alert alert-info">
  <strong>Optimisation note:</strong> recalculating the normal transformation
  matrix for <em>every fragment/pixel</em> is not great for performance. For
  better performance, calculate the matrix in C++ and make it a uniform inside
  the shaders.
</div>

<h2>The Vertex Shader</h2>

<p>Phew! That was a lot of reading, but now we get into the code. Let’s start by
looking at the vertex shader.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#version 150
</span>
<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">camera</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">model</span><span class="p">;</span>

<span class="k">in</span> <span class="kt">vec3</span> <span class="n">vert</span><span class="p">;</span>
<span class="k">in</span> <span class="kt">vec2</span> <span class="n">vertTexCoord</span><span class="p">;</span>
<span class="k">in</span> <span class="kt">vec3</span> <span class="n">vertNormal</span><span class="p">;</span>

<span class="k">out</span> <span class="kt">vec3</span> <span class="n">fragVert</span><span class="p">;</span>
<span class="k">out</span> <span class="kt">vec2</span> <span class="n">fragTexCoord</span><span class="p">;</span>
<span class="k">out</span> <span class="kt">vec3</span> <span class="n">fragNormal</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Pass some variables to the fragment shader</span>
    <span class="n">fragTexCoord</span> <span class="o">=</span> <span class="n">vertTexCoord</span><span class="p">;</span>
    <span class="n">fragNormal</span> <span class="o">=</span> <span class="n">vertNormal</span><span class="p">;</span>
    <span class="n">fragVert</span> <span class="o">=</span> <span class="n">vert</span><span class="p">;</span>
    
    <span class="c1">// Apply all matrix transformations to vert</span>
    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">camera</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">vert</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is mostly the same as the last article. The main difference is that we
have a new input variable for the surface normals called <code>vertNormal</code>. Also, we
send three variables straight through to the fragment shader without modifying
them: the vertex, the normal, and the texture coordinate.</p>

<h2>The Fragment Shader</h2>

<p>Now let’s look at the fragment shader, where all of the lighting calculations
are done.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#version 150
</span>
<span class="k">uniform</span> <span class="kt">mat4</span> <span class="n">model</span><span class="p">;</span>
<span class="k">uniform</span> <span class="kt">sampler2D</span> <span class="n">tex</span><span class="p">;</span>

<span class="k">uniform</span> <span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
   <span class="kt">vec3</span> <span class="n">position</span><span class="p">;</span>
   <span class="kt">vec3</span> <span class="n">intensities</span><span class="p">;</span> <span class="c1">//a.k.a the color of the light</span>
<span class="p">}</span> <span class="n">light</span><span class="p">;</span>

<span class="k">in</span> <span class="kt">vec2</span> <span class="n">fragTexCoord</span><span class="p">;</span>
<span class="k">in</span> <span class="kt">vec3</span> <span class="n">fragNormal</span><span class="p">;</span>
<span class="k">in</span> <span class="kt">vec3</span> <span class="n">fragVert</span><span class="p">;</span>

<span class="k">out</span> <span class="kt">vec4</span> <span class="n">finalColor</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//calculate normal in world coordinates</span>
    <span class="kt">mat3</span> <span class="n">normalMatrix</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="kt">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)));</span>
    <span class="kt">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span> <span class="o">*</span> <span class="n">fragNormal</span><span class="p">);</span>
    
    <span class="c1">//calculate the location of this fragment (pixel) in world coordinates</span>
    <span class="kt">vec3</span> <span class="n">fragPosition</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">fragVert</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    
    <span class="c1">//calculate the vector from this pixels surface to the light source</span>
    <span class="kt">vec3</span> <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">fragPosition</span><span class="p">;</span>

    <span class="c1">//calculate the cosine of the angle of incidence</span>
    <span class="kt">float</span> <span class="n">brightness</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">surfaceToLight</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">surfaceToLight</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span><span class="p">(</span><span class="n">normal</span><span class="p">));</span>
    <span class="n">brightness</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">brightness</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">//calculate final color of the pixel, based on:</span>
    <span class="c1">// 1. The angle of incidence: brightness</span>
    <span class="c1">// 2. The color/intensities of the light: light.intensities</span>
    <span class="c1">// 3. The texture and texture coord: texture(tex, fragTexCoord)</span>
    <span class="kt">vec4</span> <span class="n">surfaceColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">tex</span><span class="p">,</span> <span class="n">fragTexCoord</span><span class="p">);</span>
    <span class="n">finalColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">brightness</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensities</span> <span class="o">*</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We have a new shader uniform called <code>light</code>, which is a struct containing the
position and the intensities/color of the light.</p>

<p>The variables <code>fragTexCoord</code>, <code>fragNormal</code> and <code>fragVert</code> all come straight
from the vertex shader. <code>fragTexCoord</code> is the texture coordinate, as we’ve seen
in previous articles. <code>fragNormal</code> is the <em>untransformed</em> surface normal for
this fragment/pixel. <code>fragVert</code> is the <em>untransformed</em> coordinate of the
surface that we are drawing.</p>

<p>The first part of <code>main</code> transforms the normal into world space, as explained
in the previous section of this article.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">mat3</span> <span class="n">normalMatrix</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="kt">mat3</span><span class="p">(</span><span class="n">model</span><span class="p">)));</span>
<span class="kt">vec3</span> <span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">normalMatrix</span> <span class="o">*</span> <span class="n">fragNormal</span><span class="p">);</span>
</code></pre></div></div>

<p>The next part transforms the surface coordinate <code>fragVert</code> into world space.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec3</span> <span class="n">fragPosition</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="nf">vec4</span><span class="p">(</span><span class="n">fragVert</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
</code></pre></div></div>

<p>The <code>model</code> uniform is a 4x4 matrix, so we convert the coordinate to a <code>vec4</code> in
order to do the transformation, then we convert back to <code>vec3</code>.</p>

<p>Next, we calculate a vector from the surface coordinate to the light
coordinate, both of which are in world space.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec3</span> <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">fragPosition</span><span class="p">;</span>
</code></pre></div></div>

<p>Next, we calculate the brightness, which is equal to <code>cos(angleOfIncidence)</code>.
As explained earlier in the article, we use the dot product of the normal and a
vector pointing towards the light.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">brightness</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">surfaceToLight</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">surfaceToLight</span><span class="p">)</span> <span class="o">*</span> <span class="nf">length</span><span class="p">(</span><span class="n">normal</span><span class="p">));</span>
</code></pre></div></div>

<p>Remembering that brightness can be negative – which indicates that the light is
hitting the <em>back</em> of the surface – we restrict the brightness to a value
between 0 and 1. Negative values will become 0, which means completely dark.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">brightness</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">brightness</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Finally, using the brightness, the light intensities and the surface color, we
can calculate the color of the fragment/pixel.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec4</span> <span class="n">surfaceColor</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">tex</span><span class="p">,</span> <span class="n">fragTexCoord</span><span class="p">);</span>
<span class="n">finalColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">brightness</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensities</span> <span class="o">*</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
</code></pre></div></div>

<p><code>texture(tex, fragTexCoord)</code> will get the color of the surface from the
texture. This surface color determines how the intensities of the light are
reflected or absorbed. Remember the formula <code>intensities × surface color =
reflected intensities</code>. We are implementing that here with the code
<code>light.intensities * surfaceColor.rgb</code>.</p>

<p>After we calculate the reflected intensities with <code>light.intensities *
surfaceColor.rgb</code>, we multiply them by <code>brightness</code> to get the
final color. Multiplying by the brightness will darken the reflected
intensities based on the angle of incidence.</p>

<p>The light intensities are a <code>vec3</code> (RGB), but the final color is a <code>vec4</code>
(RGBA), so we convert the intensities to a <code>vec4</code> and set the alpha channel to
the alpha value from the texture: <code>surfaceColor.a</code>. This means the rendered
surface will be transparent wherever the texture is transparent.</p>

<h2>Changes In main.cpp</h2>

<p>The majority of lighting is done in the fragment shader, so the C++ code
changes are fairly minor.</p>

<p>We have a new global called <code>gLight</code> that is an exact copy of the light struct
in the fragment shader.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Light</span> <span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">intensities</span><span class="p">;</span> <span class="c1">//a.k.a. the color of the light</span>
<span class="p">};</span>

<span class="c1">// ...</span>

<span class="n">Light</span> <span class="n">gLight</span><span class="p">;</span>
</code></pre></div></div>

<p>We update the VBO to include a normal for each vertex. The old buffer data
looked like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  X     Y     Z       U     V</span>
<span class="c1">//bottom</span>
<span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
 <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
<span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>
 <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
 <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>
<span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>
<span class="c1">//...</span>
</code></pre></div></div>

<p>And now it looks like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//  X     Y     Z       U     V          Normal</span>
<span class="c1">//bottom</span>
<span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
 <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
<span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
 <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
 <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
<span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">,</span>   <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
<span class="c1">//...</span>
</code></pre></div></div>

<p>The vertices shown above make up the bottom face of the wooden crate. Notice
how they all have the same normal, (0, -1, 0), which is a unit vector pointing
straight down the Y axis. There are six faces on the wooden crate, and each
face has a normal that points directly down the positive or negative direction
of the X, Y, or Z axis.</p>

<p>Because the format of the VBO has changed to include normals, we have to change
the VAO as well. This is the old VAO setup code:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// connect the xyz to the "vert" attribute of the vertex shader</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vert"</span><span class="p">));</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vert"</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// connect the uv coords to the "vertTexCoord" attribute of the vertex shader</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vertTexCoord"</span><span class="p">));</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vertTexCoord"</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">,</span>  <span class="mi">5</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">)));</span>
</code></pre></div></div>

<p>And this is the new VAO setup code:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// connect the xyz to the "vert" attribute of the vertex shader</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vert"</span><span class="p">));</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vert"</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">8</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// connect the uv coords to the "vertTexCoord" attribute of the vertex shader</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vertTexCoord"</span><span class="p">));</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vertTexCoord"</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">,</span>  <span class="mi">8</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">)));</span>

<span class="c1">// connect the normal to the "vertNormal" attribute of the vertex shader</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vertNormal"</span><span class="p">));</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="n">gWoodenCrate</span><span class="p">.</span><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">attrib</span><span class="p">(</span><span class="s">"vertNormal"</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_TRUE</span><span class="p">,</span>  <span class="mi">8</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="n">GLvoid</span><span class="o">*</span><span class="p">)(</span><span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">GLfloat</span><span class="p">)));</span>
</code></pre></div></div>

<p>It’s basically the same, with the addition of the normals.</p>

<p>Now let’s look at how rendering has changed inside the <code>RenderInstance</code>
function. Before we render each instance, all we have to do is set the position
and color of the light in the shaders. We take the position and intensities
straight out of the <code>gLight</code> global.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">setUniform</span><span class="p">(</span><span class="s">"light.position"</span><span class="p">,</span> <span class="n">gLight</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
<span class="n">shaders</span><span class="o">-&gt;</span><span class="n">setUniform</span><span class="p">(</span><span class="s">"light.intensities"</span><span class="p">,</span> <span class="n">gLight</span><span class="p">.</span><span class="n">intensities</span><span class="p">);</span>
</code></pre></div></div>

<p>Next, let’s look at the new keyboard controls to change the light inside of the
<code>Update</code> function.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//move light</span>
<span class="k">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">gWindow</span><span class="p">,</span> <span class="sc">'1'</span><span class="p">))</span>
    <span class="n">gLight</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">gCamera</span><span class="p">.</span><span class="n">position</span><span class="p">();</span>

<span class="c1">// change light color</span>
<span class="k">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">gWindow</span><span class="p">,</span> <span class="sc">'2'</span><span class="p">))</span>
    <span class="n">gLight</span><span class="p">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//red</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">gWindow</span><span class="p">,</span> <span class="sc">'3'</span><span class="p">))</span>
    <span class="n">gLight</span><span class="p">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//green</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">gWindow</span><span class="p">,</span> <span class="sc">'4'</span><span class="p">))</span>
    <span class="n">gLight</span><span class="p">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//white</span>
</code></pre></div></div>

<p>Pressing the <kbd>1</kbd> key sets the position of the light to the current
position of the camera. Moving the light around will allow us to observe how
the angle of incidence affects the brightness of the surfaces.</p>

<p>Pressing the <kbd>2</kbd>, <kbd>3</kbd>, and <kbd>4</kbd> keys will change the
color of the light.</p>

<p>Inside the <code>AppMain</code> function we set the initial position and color of the
light when the program starts.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gLight</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">gCamera</span><span class="p">.</span><span class="n">position</span><span class="p">();</span>
<span class="n">gLight</span><span class="p">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//white</span>
</code></pre></div></div>

<p>Lastly, there are a couple of changes that are unrelated to lighting. I
increased the movement speed of the camera, because it seemed a bit slow. I
also increased the near plane distance of the camera from 0.01 to 0.5, because
0.01 was too small, and it as causing weird jagged edges to appear on the
wooden crates.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gCamera</span><span class="p">.</span><span class="n">setNearAndFarPlanes</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">100.0</span><span class="n">f</span><span class="p">);</span>
</code></pre></div></div>

<p>That’s it! We now have a single, diffuse, point light. This is the first step
in 3D lighting, and we will build upon it in the next couple of articles.</p>

<h2>Per-vertex Vs Per-fragment Lighting</h2>

<blockquote class="pull-right">
  Per-fragment lighting looks better than per-vertex lighting, which is one
  good reason to switch from the old fixed-function pipeline to shaders.
</blockquote>

<p>In this article we’ve implemented per-fragment lighting, also known as <a href="http://en.wikipedia.org/wiki/Phong_shading">Phong
shading</a> – not to be confused with the <a href="http://en.wikipedia.org/wiki/Phong_reflection_model">Phong reflection model</a>. We could
have chosen, instead, to implement per-vertex lighting, also known as <a href="http://en.wikipedia.org/wiki/Gouraud_shading">Gouraud
shading</a>. The difference between the two implementations is where the
lighting calculations are performed: in the fragment shader, or in the vertex
shader. The old OpenGL fixed-function pipeline implemented per-vertex shading,
if you wanted per-fragment lighting you had to write your own shaders.
Per-fragment lighting looks better than per-vertex lighting, which is one good
reason to switch from the old fixed-function pipeline to shaders.</p>

<p>If we chose per-vertex lighting, the brightness would be calculated at each
vertex – that is, at each corner of the wooden crates. Then, the brightness
would be <em>interpolated</em> across all the pixels in each triangle. For example, if
one corner was dark, and the other was bright, the pixels in between  the two
corners would fade from dark to bright. Now let’s look at one of the crates in
the screenshot for this article:</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/sucky-for-per-vertex.png">
  </figure>
</p>

<p>Notice how all of the corners are dark, because the bright area is right in the
middle of the surface. If we had implemented per-vertex lighting, this would
look <em>horrible</em>. All the corners are dark, so the entire surface would be dark
too. It would look wrong, as if there was no light in front of the surface.</p>

<p>This is the problem with per-vertex lighting – it often looks wrong, especially
if the vertices of the model are far apart. One solution is to increase the
number of vertices in the model. The two images below show per-vertex lighting
applied to two spheres: one with few vertices (low-poly), and one with lots of
vertices (high-poly).</p>

<p>
  <figure>
    <img src="/images/posts/modern-opengl-06/Gouraud_low.gif">
    <img src="/images/posts/modern-opengl-06/Gouraud_high.gif">
    <figcaption>
      Images by <a href="http://en.wikipedia.org/wiki/File:Gouraud_high.gif">Zom-B</a>
    </figcaption>
  </figure>
</p>

<p>The low-poly sphere has a weird pentagon-shaped highlight, but the high-poly
sphere has a circular highlight that looks more correct.</p>

<p>Using per-fragment lighting, we sidestep this problem. Instead of calculating
the brightness at each corner of the wooden crates, we calculate the brightness
at <em>each pixel</em>. This why per-fragment lighting looks better than per-vertex
lighting: it’s doing more lighting calculations per surface, so it’s more
accurate.</p>

<blockquote class="pull-right">
  Per-vertex lighting is generally faster than per-fragment lighting.
</blockquote>

<p>There is a tradeoff, however. Per-vertex lighting requires three calculations
per triangle. Per-fragment lighting requires one calculation per fragment that
the triangle covers, which is usually a lot more than three. Also, increasing
the screen resolution increases the number of fragments per triangle. More
calculations means that rendering takes longer, so per-vertex lighting is
generally faster than per-fragment lighting. Modern desktop hardware can handle
per-fragment lighting fairly easily, but the speed difference can still be an
issue for older hardware and mobile devices.</p>

<h2>Future Article Sneak Peek</h2>

<p>In the next few articles, we will be implementing more aspects of lighting. We
will be implementing the ambient and specular components of the Phong
reflection model. We will also look at other types of light: directional
lights, and spotlights.</p>

<h2>Additional Resources</h2>

<ul>
  <li>
<a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-8-basic-shading/">Tutorial 8 : Basic shading</a> from opengl-tutorial.org</li>
  <li>
<a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-4:-Rendering-a-Dynamic-3D-Scene-with-Phong-Shading.html">Chapter 4: Rendering a Dynamic 3D Scene with Phong Shading</a> of Joe Groff’s <em>An intro to modern OpenGL</em>.</li>
  <li>From the <em>Learning Modern 3D Graphics Programming</em> book:
    <ul>
      <li><a href="http://www.arcsynthesis.org/gltut/Illumination/Tutorial%2009.html">Lights On</a></li>
      <li><a href="http://www.arcsynthesis.org/gltut/Illumination/Tut09%20Normal%20Transformation.html">Normal Transformation</a></li>
    </ul>
  </li>
  <li>
<a href="http://ogldev.atspace.co.uk/www/tutorial18/tutorial18.html">Tutorial 18 - Diffuse Lighting</a> of <em>OGLdev Modern OpenGL Tutorials</em>
</li>
  <li>From the <em>OpenGL programming wikibook</em> book:
    <ul>
      <li><a href="http://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Diffuse_Reflection">Diffuse Reflection</a></li>
      <li>
<a href="http://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Smooth_Specular_Highlights">Some discussion about per-vertex vs per-fragment lighting</a>.</li>
    </ul>
  </li>
  <li>Related Wikipedia articles:
    <ul>
      <li><a href="http://en.wikipedia.org/wiki/Angle_of_incidence">Angle of Incidence</a></li>
      <li><a href="http://en.wikipedia.org/wiki/Phong_reflection_model">Phong reflection model</a></li>
      <li><a href="http://en.wikipedia.org/wiki/Diffuse_reflection">Diffuse reflection</a></li>
      <li><a href="http://en.wikipedia.org/wiki/Phong_shading">Phong shading</a></li>
      <li><a href="http://en.wikipedia.org/wiki/Gouraud_shading">Gouraud Shading</a></li>
      <li><a href="http://en.wikipedia.org/wiki/White#Science">White light</a></li>
      <li><a href="http://en.wikipedia.org/wiki/Additive_color">Additive color</a></li>
      <li><a href="http://en.wikipedia.org/wiki/Normal_(geometry)">Normal (geometry)</a></li>
      <li><a href="http://en.wikipedia.org/wiki/Dot_product">Vector Dot Product</a></li>
    </ul>
  </li>
</ul>

</div>

  <footer>
    <div class="tw-rounded-3xl tw-bg-pink-100 tw-p-8 tw-my-16 tw-text-center tw-bg-opacity-50">
      <p class="tw-text-2xl tw-uppercase tw-text-pink-900 tw-font-black tw-mb-4">Enjoy this?</p>

      <p class="tw-flex tw-flex-col sm:tw-flex-row tw-justify-center tw-item-center sm:tw-items-baseline">
        <a href="/feed/" class="tw-flex-1 tw-bg-pink-500 tw-py-3 tw-px-4 tw-rounded-lg tw-text-pink-100 tw-ring-2 tw-ring-pink-300 tw-max-w-52 hover:tw-text-white">Subscribe via RSS</a>
      </p>

      <p class="tw-text-center tw-mt-4 tw-mb-0 tw-text-pink-900">
        <em>Found a mistake?</em> Pull requests are welcome on
        <a href="https://github.com/tomdalling/tomdalling.com">GitHub</a>.
      </p>
</div>

    


    
      <h2>Comments</h2>
      <div id="disqus_thread"></div>
      <script type="text/javascript" id="disqus_script">
        var disqus_shortname = "tomdalling";
        var disqus_identifier = "1139 http://tomdalling.com/?p=1139";
        var disqus_title = "Modern OpenGL 06 – Diffuse Point Lighting";
        var disqus_url = "https://www.tomdalling.com/blog/modern-opengl/06-diffuse-point-lighting/";

        (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments.</a>
</noscript>
    

  </footer>
</article>
</main>

      <aside class="tw-px-4 tw-text-center lg:tw-text-left lg:tw-w-1/3 tw-flex-none">

        <div class="tw-text-lg tw-font-title tw-mb-1">Subscribe</div>
        <ul class="tw-space-y-2">
          <li>
            <a href="/blog/feed/">
              <i class="fa fa-rss"></i> RSS
            </a>
          </li>
        </ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Recent Posts</div>
        <ul class="recent-posts tw-space-y-2">
          
        <li><a href="/blog/management/the-difference-between-management-and-leadership/">The Difference Between Management And Leadership</a></li>
<li><a href="/blog/random-stuff/feedback-is-a-gift/">Feedback Is Literally A Gift</a></li>
<li><a href="/blog/software-processes/against-must-haves-part-three/">Against Must-Haves (Part Three)</a></li>
<li><a href="/blog/software-processes/high-performance-requires-process/">High Performance Requires Process</a></li>
<li><a href="/blog/software-processes/ditch-the-umbrella-and-grab-some-sunnies/">Ditch The Umbrella And Grab Some Sunnies</a></li>
</ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Categories</div>
        <ul class="categories tw-space-y-2">
          
        <li>
            <a href="/blog/cocoa/" class="category">Cocoa</a>
            (<span class="post-count">5</span>
            <a class="feed" href="/blog/cocoa/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/coding-styleconventions/" class="category">Coding Style/Conventions</a>
            (<span class="post-count">3</span>
            <a class="feed" href="/blog/coding-styleconventions/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/coding-tips/" class="category">Coding Tips</a>
            (<span class="post-count">4</span>
            <a class="feed" href="/blog/coding-tips/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/management/" class="category">Management</a>
            (<span class="post-count">1</span>
            <a class="feed" href="/blog/management/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/mentoring/" class="category">Mentoring Notes</a>
            (<span class="post-count">3</span>
            <a class="feed" href="/blog/mentoring/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/random-stuff/" class="category">Miscellaneous</a>
            (<span class="post-count">5</span>
            <a class="feed" href="/blog/random-stuff/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/modern-opengl/" class="category">Modern OpenGL Series</a>
            (<span class="post-count">10</span>
            <a class="feed" href="/blog/modern-opengl/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/ruby/" class="category">Ruby</a>
            (<span class="post-count">2</span>
            <a class="feed" href="/blog/ruby/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/software-design/" class="category">Software Design</a>
            (<span class="post-count">12</span>
            <a class="feed" href="/blog/software-design/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/software-processes/" class="category">Software Processes</a>
            (<span class="post-count">10</span>
            <a class="feed" href="/blog/software-processes/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/testing/" class="category">Testing</a>
            (<span class="post-count">2</span>
            <a class="feed" href="/blog/testing/feed/"><i class="fa fa-rss"></i></a>)
          </li>
<li>
            <a href="/blog/web/" class="category">Web</a>
            (<span class="post-count">1</span>
            <a class="feed" href="/blog/web/feed/"><i class="fa fa-rss"></i></a>)
          </li>
</ul>

        <div class="tw-text-lg tw-font-title tw-mb-1 tw-mt-6">Archives</div>
        <ul class="archives tw-space-y-2">
          
        <li>
            <a href="/blog/2025/" class="year">2025</a>
            (<span class="post-count">3</span>)
          </li>
<li>
            <a href="/blog/2024/" class="year">2024</a>
            (<span class="post-count">2</span>)
          </li>
<li>
            <a href="/blog/2023/" class="year">2023</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2022/" class="year">2022</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2021/" class="year">2021</a>
            (<span class="post-count">6</span>)
          </li>
<li>
            <a href="/blog/2020/" class="year">2020</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2016/" class="year">2016</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2015/" class="year">2015</a>
            (<span class="post-count">2</span>)
          </li>
<li>
            <a href="/blog/2014/" class="year">2014</a>
            (<span class="post-count">3</span>)
          </li>
<li>
            <a href="/blog/2013/" class="year">2013</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2012/" class="year">2012</a>
            (<span class="post-count">10</span>)
          </li>
<li>
            <a href="/blog/2011/" class="year">2011</a>
            (<span class="post-count">1</span>)
          </li>
<li>
            <a href="/blog/2010/" class="year">2010</a>
            (<span class="post-count">5</span>)
          </li>
<li>
            <a href="/blog/2009/" class="year">2009</a>
            (<span class="post-count">9</span>)
          </li>
</ul>

      </aside>

    </div>

    <footer class="page-footer">
      <p>© 2009 – <span class="current-year">2025</span> Tom Dalling</p>

      <p class="social">
        <a href="https://github.com/tomdalling">
          <i class="fa fa-lg fa-github"></i>
        </a>
        <a href="https://stackoverflow.com/users/108105/tom-dalling">
          <i class="fa fa-lg fa-stack-overflow"></i>
        </a>
        <a href="mailto:tom%20at%20tomdalling%20com">
          <i class="fa fa-lg fa-envelope"></i>
        </a>
      </p>
    </footer>

    <script src="/bundles/all.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$$','$$']],
          displayMath: [['[blockmath]', '[/blockmath]']]
        }
      });
    </script>
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  </body>
</html>
